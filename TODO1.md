**Rust Backend (`src-tauri/`):**

1.  **`error.rs`**:
    *   TODO: Ensure all potential error sources are mapped to `AppError` variants.
2.  **`models.rs`**:
    *   TODO: Finalize all fields for `ProjectSettings`, `Task`, `TaskAttempt`, `CoderOutput`, `CrateInfo`, `GlobalLogEntry`.
    *   TODO: Consider adding more specific `TaskType` variants.
    *   TODO: Add `details` field to `TaskAttempt` for richer error/success context.
3.  **`baml_client/mod.rs`**:
    *   TODO: This entire module needs to be **auto-generated by the BAML CLI** based on `.baml` files.
    *   TODO: Create actual `.baml` files (`planner_baml.baml`, `coder_baml.baml`) with robust prompt engineering for all LLM interactions.
    *   TODO: Configure `baml_options.json` with actual LLM client details (OpenAI, Anthropic, Gemini, etc.) and model aliases.
    *   TODO: Implement proper error handling and retries within the BAML function definitions or client configuration.
4.  **`app_state.rs`**:
    *   TODO: Implement loading `ProjectSettings` from a configuration file on disk (e.g., in app data directory or project root).
    *   TODO: Implement saving `ProjectSettings` to disk.
    *   TODO: Consider if `HumanInterfaceService` needs to be part of `AppServices` or if `AppHandle` is always passed.
5.  **`scaffolder.rs`**:
    *   TODO: Implement `create_dir_all_verbose` and `create_file_with_content_verbose` helpers.
    *   TODO: Implement the full project scaffolding logic as detailed in earlier discussions (creating all directories and placeholder files for `codebase`, `codebase-docs`, `docs`).
    *   TODO: Allow custom scaffold templates (e.g., from `ProjectSettings.project_scaffold_template_url`).
6.  **`agents/planner.rs`**:
    *   TODO: `analyze_and_decompose_spec`:
        *   Implement robust fetching of `architecture_content` and `file_index_content`.
        *   Implement the actual BAML call to `baml_client.decompose_specification`.
        *   Implement thorough post-processing of `BamlTaskOutput` to create valid, hierarchical `Task` models (validate IDs, dependencies, build parent/child relationships).
    *   TODO: `select_next_task`: Implement more sophisticated task selection logic (priority, readiness, considering `ProjectStatus::SelfCorrecting`).
    *   TODO: `prepare_context_for_coder`:
        *   Implement intelligent parsing of `task.description` to identify relevant files, functions, structs, crates.
        *   Use `WorkspaceService.search_code_with_sidecar_ripgrep` and `read_file_from_project` for code context.
        *   Use `KnowledgeManagerService.get_crate_documentation_summary` for crate context.
        *   Implement context summarization/chunking if total context exceeds LLM limits.
        *   Return distinct context pieces (`relevant_code_context`, `relevant_crate_docs`) for the BAML Coder function.
    *   TODO: `process_coder_output_and_verification`:
        *   Implement more detailed parsing of `verification_stderr` to provide better error messages for `TaskStatus::BlockedByError`.
        *   Refine self-correction logic: how does it decide to retry? Does it modify the task description for the Coder?
        *   Handle `ProjectStatus::AwaitingHumanInput` more gracefully if max retries are hit.
7.  **`agents/coder.rs`**:
    *   TODO: `execute_task`:
        *   Implement the actual BAML call to `baml_client.execute_coding_task`.
        *   Ensure `previous_attempt_feedback` is formatted effectively for the LLM.
        *   Ensure `BamlCoderOutput` is correctly mapped to `CoderOutput` model.
8.  **`services/workspace.rs`**:
    *   TODO: `read_file_from_project`, `write_file_to_project`: Add path validation to prevent escaping project root.
    *   TODO: `apply_coder_output`: Ensure robust handling of `FileAction::Deleted` for both code and docs.
    *   TODO: `run_verification_stage`:
        *   Replace simplified blocking `StdCommand` with `tokio::process::Command` or `tauri::api::process::Command` for true async execution and better output streaming.
        *   Make verification stages (`fmt`, `clippy`, `test`, `check`) configurable, possibly based on `TaskType`.
    *   TODO: `search_code_with_sidecar_ripgrep`:
        *   Ensure `binaries/rg` sidecar is correctly configured in `tauri.conf.json` and bundled for all target platforms.
        *   Implement robust parsing of `ripgrep`'s JSON output into a structured format.
        *   Handle cases where `ripgrep` finds no matches (exit code 1) gracefully.
    *   TODO: `git_commit_changes`: Implement actual `git add .` and `git commit -m "{message}"` using `StdCommand` or `tokio::process::Command` within the `codebase_root`. Handle Git not being installed or not being a repo.
    *   TODO: Add more Git operations: `git_init_if_needed`, `git_create_branch`, `git_push_to_remote`.
    *   TODO: Add file/directory listing functions.
9.  **`services/knowledge_manager.rs`**:
    *   TODO: `get_crate_documentation_summary`:
        *   Implement reading from local cache `docs/crate-docs/{crate_name}.md`.
        *   Implement RAG vector DB integration (requires choosing and setting up a vector DB).
        *   Implement fetching from docs.rs (HTTP GET, HTML parsing) and summarizing with a Tier 2 BAML call.
    *   TODO: `update_project_file_index`:
        *   Implement recursive directory scan of `codebase/`.
        *   Implement file summarization (heuristic or Tier 2 BAML call).
        *   Format and write the Markdown index.
    *   TODO: `qualify_and_add_crate`:
        *   Implement fetching metadata from `crates.io` API.
        *   Implement fetching docs/README from crate source or docs.rs.
        *   Use Tier 2 BAML call for documentation quality assessment and summary generation.
        *   Write summary to `docs/crate-docs/{crate_name}.md`.
        *   Update a manifest (e.g., `docs/crate-docs/manifest.json`) with `CrateInfo`.
    *   TODO: `get_known_crates`: Load from `docs/crate-docs/manifest.json` or by scanning `.md` files.
10. **`services/human_interface.rs`**:
    *   TODO: `request_human_input_modal`: Fully implement the async workflow for showing a modal on the frontend and receiving the response back in Rust, likely involving channels or a request/response pattern managed by the Planner/main loop.
11. **`main.rs`**:
    *   TODO: `load_settings`: Implement actual loading from disk.
    *   TODO: `save_settings`: Implement actual saving to disk.
    *   TODO: `initialize_project`: Validate project structure more thoroughly.
    *   TODO: `load_spec_files_from_project`: Implement actual file listing and preview generation using `WorkspaceService`.
    *   TODO: `start_full_processing_for_spec`: Ensure robust error handling and state transitions.
    *   TODO: `run_main_execution_loop`:
        *   Refine the main loop logic for robustness, especially around state transitions (`ProjectStatus`) and error handling.
        *   Implement a delay or event-driven mechanism if it's a persistent loop, rather than tight looping.
        *   Ensure `task_to_run.context_summary` is updated after `prepare_context_for_coder`.
        *   Handle the case where `prepare_context_for_coder` itself fails.
    *   TODO: `submit_human_response`: Implement logic to potentially modify task or create follow-up tasks based on human input.
    *   TODO: `get_crate_info_cmd`: Fetch full `CrateInfo` from `KnowledgeManagerService`.
    *   TODO: `approve_crate_cmd`: Update `CrateInfo.approval_status` and persist it.
    *   TODO: Implement robust logging throughout all commands using `log_to_state_and_emit`.
    *   TODO: `RunEvent::WindowEvent` and `RunEvent::ExitRequested`: Implement proper state saving and cleanup on app close/exit.
    *   TODO: Add more Tauri commands for all necessary frontend interactions (e.g., getting specific task details, getting crate list, managing settings).
    *   TODO: Tracing setup: Ensure it's configured optimally for development and release.

**React Frontend (`src/`):**

1.  **`utils/tauriApi.ts`**:
    *   TODO: Define comprehensive TypeScript interfaces for ALL Rust models (`ProjectSettings`, `CurrentProjectSession`, `Task`, `TaskAttempt`, `CoderOutput`, `SpecFile`, `CrateInfo`, `GlobalLogEntry`, enums, etc.) to ensure type safety.
    *   TODO: Add API functions for ALL Tauri commands defined in `main.rs`.
    *   TODO: Add more specific event listener functions (e.g., `listenToSessionStateChanges`, `listenToTaskUpdates`).
2.  **`App.tsx`**:
    *   TODO: Implement more robust state synchronization with the backend, possibly using a dedicated event like `session-state-update` from Rust instead of just polling or relying on log messages.
    *   TODO: Handle errors from `tauriApi` calls gracefully, displaying user-friendly messages.
3.  **`components/Dashboard.tsx`**:
    *   TODO: Display more detailed task statistics (In Progress, Blocked, etc.).
    *   TODO: Implement "Recent Activity Log" by filtering and displaying `sessionState.logs`.
    *   TODO: Implement "Alerts/Notifications Area" for critical issues or human input requests.
    *   TODO: Add a button to trigger `run_main_execution_loop` if the system is in a state like `ReadyToExecute` or `Idle` (with tasks).
4.  **`components/SpecsView.tsx`**:
    *   TODO: Implement the "Initialize Existing Project" UI and connect it to `tauriApi.initializeProject`.
    *   TODO: Implement the "Scaffold New Project" UI fully.
    *   TODO: Display spec loading errors more clearly.
    *   TODO: Add a proper Markdown editor/viewer for creating/editing spec content (e.g., using `react-markdown` and a simple textarea or a more advanced editor component).
5.  **`components/TaskProgressView.tsx`**:
    *   TODO: Implement hierarchical rendering of tasks if `parent_id` and `sub_task_ids` are used.
    *   TODO: On task click, show a modal or detail pane with:
        *   Full task description.
        *   `context_summary`.
        *   List of `TaskAttempt`s with their details (generated code summary, verification output, errors).
        *   `last_coder_output` (diffs of changed files).
    *   TODO: Add controls to manually retry a failed task (if appropriate), or flag for specific human review.
    *   TODO: Visually distinguish tasks that are part of a self-correction loop.
6.  **`components/KnowledgeBaseView.tsx`**:
    *   TODO: Implement UI for listing known crates (`sessionState.known_crates`).
    *   TODO: Allow users to request qualification for a new crate (input field + button calling a new Tauri command `qualify_new_crate_cmd`).
    *   TODO: Allow users to approve/reject pending crates (calling `approve_crate_cmd`).
    *   TODO: Display `CrateInfo` details (summary, version, status).
    *   TODO: Implement viewer for `docs/architecture.md` and `docs/file-index.md` (fetch content via Tauri command).
7.  **`components/SystemTerminalView.tsx`**:
    *   TODO: Add filtering options for logs (by level, component, task ID).
    *   TODO: Add search functionality within logs.
    *   TODO: Implement an input field for diagnostic commands (e.g., `search_codebase` via `tauriApi`).
8.  **`components/SettingsView.tsx`**:
    *   TODO: Create form fields for all `ProjectSettings` (LLM aliases, API key, autonomy level, Git strategy, max retries).
    *   TODO: Implement loading settings via `tauriApi.loadSettings` on mount.
    *   TODO: Implement saving settings via `tauriApi.saveSettings`.
9.  **`components/HumanInputDialog.tsx`**:
    *   TODO: Ensure it's displayed correctly when `humanInputRequest` state is set in `App.tsx`.
    *   TODO: Style it to be non-intrusive but clear.
10. **General Frontend**:
    *   TODO: Implement consistent error handling and user feedback (e.g., using toasts or a notification area).
    *   TODO: Add loading indicators for all async operations.
    *   TODO: Improve styling and UX across all components.
    *   TODO: Implement routing if the number of views grows significantly (e.g., using `react-router-dom`).
    *   TODO: Ensure all interactive elements are accessible.
    *   TODO: Add a "Code Review" view to display diffs from `CoderOutput.changed_files` more formally.

This list is extensive, reflecting the complexity of the system we've designed. Each `TODO` represents a significant piece of implementation work.
