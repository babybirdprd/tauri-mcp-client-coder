This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
index.html
package.json
public/tauri.svg
public/vite.svg
README.md
src-tauri/.gitignore
src-tauri/build.rs
src-tauri/capabilities/default.json
src-tauri/Cargo.toml
src-tauri/src/agents/coder,rs
src-tauri/src/agents/mod.rs
src-tauri/src/agents/planner.rs
src-tauri/src/app_state.rs
src-tauri/src/baml_client/mod.rs
src-tauri/src/config.rs
src-tauri/src/error.rs
src-tauri/src/lib.rs
src-tauri/src/main.rs
src-tauri/src/mcp_server/handler.rs
src-tauri/src/mcp_server/mcp_client_runtime.rs
src-tauri/src/mcp_server/mod.rs
src-tauri/src/mcp_server/runner.rs
src-tauri/src/mcp_server/tools.rs
src-tauri/src/models.rs
src-tauri/src/scaffolder.rs
src-tauri/src/services/human_interface.rs
src-tauri/src/services/knowledge_manager.rs
src-tauri/src/services/workspace.rs
src-tauri/tauri.conf.json
src/App.css
src/App.tsx
src/assets/react.svg
src/components/Dashboard.tsx
src/components/GlobalSearch.tsx
src/components/HumanInputDialog.tsx
src/components/KnowledgeBaseView.tsx
src/components/Nav.tsx
src/components/SettingsView.tsx
src/components/SpecsView.tsx
src/components/SystemTerminalView.tsx
src/components/TaskProgressView.tsx
src/index.css
src/main.tsx
src/utils/tauriApi.ts
src/vite-env.d.ts
TODO1.md
TODO2.md
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="public/tauri.svg">
<svg width="206" height="231" viewBox="0 0 206 231" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M143.143 84C143.143 96.1503 133.293 106 121.143 106C108.992 106 99.1426 96.1503 99.1426 84C99.1426 71.8497 108.992 62 121.143 62C133.293 62 143.143 71.8497 143.143 84Z" fill="#FFC131"/>
<ellipse cx="84.1426" cy="147" rx="22" ry="22" transform="rotate(180 84.1426 147)" fill="#24C8DB"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M166.738 154.548C157.86 160.286 148.023 164.269 137.757 166.341C139.858 160.282 141 153.774 141 147C141 144.543 140.85 142.121 140.558 139.743C144.975 138.204 149.215 136.139 153.183 133.575C162.73 127.404 170.292 118.608 174.961 108.244C179.63 97.8797 181.207 86.3876 179.502 75.1487C177.798 63.9098 172.884 53.4021 165.352 44.8883C157.82 36.3744 147.99 30.2165 137.042 27.1546C126.095 24.0926 114.496 24.2568 103.64 27.6274C92.7839 30.998 83.1319 37.4317 75.8437 46.1553C74.9102 47.2727 74.0206 48.4216 73.176 49.5993C61.9292 50.8488 51.0363 54.0318 40.9629 58.9556C44.2417 48.4586 49.5653 38.6591 56.679 30.1442C67.0505 17.7298 80.7861 8.57426 96.2354 3.77762C111.685 -1.01901 128.19 -1.25267 143.769 3.10474C159.348 7.46215 173.337 16.2252 184.056 28.3411C194.775 40.457 201.767 55.4101 204.193 71.404C206.619 87.3978 204.374 103.752 197.73 118.501C191.086 133.25 180.324 145.767 166.738 154.548ZM41.9631 74.275L62.5557 76.8042C63.0459 72.813 63.9401 68.9018 65.2138 65.1274C57.0465 67.0016 49.2088 70.087 41.9631 74.275Z" fill="#FFC131"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M38.4045 76.4519C47.3493 70.6709 57.2677 66.6712 67.6171 64.6132C65.2774 70.9669 64 77.8343 64 85.0001C64 87.1434 64.1143 89.26 64.3371 91.3442C60.0093 92.8732 55.8533 94.9092 51.9599 97.4256C42.4128 103.596 34.8505 112.392 30.1816 122.756C25.5126 133.12 23.9357 144.612 25.6403 155.851C27.3449 167.09 32.2584 177.598 39.7906 186.112C47.3227 194.626 57.153 200.784 68.1003 203.846C79.0476 206.907 90.6462 206.743 101.502 203.373C112.359 200.002 122.011 193.568 129.299 184.845C130.237 183.722 131.131 182.567 131.979 181.383C143.235 180.114 154.132 176.91 164.205 171.962C160.929 182.49 155.596 192.319 148.464 200.856C138.092 213.27 124.357 222.426 108.907 227.222C93.458 232.019 76.9524 232.253 61.3736 227.895C45.7948 223.538 31.8055 214.775 21.0867 202.659C10.3679 190.543 3.37557 175.59 0.949823 159.596C-1.47592 143.602 0.768139 127.248 7.41237 112.499C14.0566 97.7497 24.8183 85.2327 38.4045 76.4519ZM163.062 156.711L163.062 156.711C162.954 156.773 162.846 156.835 162.738 156.897C162.846 156.835 162.954 156.773 163.062 156.711Z" fill="#24C8DB"/>
</svg>
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# Tauri + React + Typescript

This template should help get you started developing with Tauri, React and Typescript in Vite.

## Recommended IDE Setup

- [VS Code](https://code.visualstudio.com/) + [Tauri](https://marketplace.visualstudio.com/items?itemName=tauri-apps.tauri-vscode) + [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer)
</file>

<file path="src-tauri/.gitignore">
# Generated by Cargo
# will have compiled files and executables
/target/

# Generated by Tauri
# will have schema files for capabilities auto-completion
/gen/schemas
</file>

<file path="src-tauri/build.rs">
fn main() {
    tauri_build::build()
}
</file>

<file path="src-tauri/src/agents/coder,rs">
use std::sync::Arc;
use parking_lot::Mutex;
use crate::app_state::AppServices;
use crate::models::{Task, CoderOutput, ChangedFileContent, FileAction, GlobalLogEntry, LogLevel, TaskAttempt, TaskType, ProjectSettings};
use crate::error::{AppError, Result as AppResult};
use crate::baml_client::{BamlClient, BamlCoderOutput, BamlChangedFileOutput, BamlFileAction};

fn model_task_type_to_string(model_type: &TaskType) -> String { format!("{:?}", model_type) }
fn baml_coder_output_to_model(baml_out: BamlCoderOutput, task_id_from_input: String) -> CoderOutput { /* ... as before ... */ CoderOutput { task_id: task_id_from_input, changed_files: vec![], generated_docs: vec![], notes: None, success: false, error_message: None } }

pub struct CoderAgent {
    services: Arc<AppServices>,
    baml_client: Arc<BamlClient>,
}

impl CoderAgent {
    pub fn new(services: Arc<AppServices>, baml_client: Arc<BamlClient>) -> Self { Self { services, baml_client } }

    fn log_entry(&self, message: String, level: LogLevel, task_id: Option<String>, details: Option<serde_json::Value>) -> GlobalLogEntry {
        GlobalLogEntry { id: Uuid::new_v4().to_string(), timestamp: std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap_or_default().as_millis() as u64, level, component: "CoderAgent".to_string(), message, task_id, details }
    }

    pub async fn execute_task(
        &self, task: &mut Task, relevant_code_context: &str, relevant_crate_docs: &str, settings: &ProjectSettings,
    ) -> AppResult<(CoderOutput, Vec<GlobalLogEntry>)> {
        let mut logs = Vec::new();
        task.current_attempt_number += 1; // Increment attempt counter for this execution
        let attempt_num = task.current_attempt_number;
        let log_msg_prefix = format!("[Task {} Att.{}] ", task.id, attempt_num);

        logs.push(self.log_entry(format!("{}Starting BAML execution.", log_msg_prefix), LogLevel::Info, Some(task.id.clone()), None));

        let previous_attempt_feedback = if attempt_num > 1 {
            task.attempts.last().map(|att| {
                format!("Previous attempt ({}) failed. Verification Output (last 200 chars):\nSTDOUT: ...{}\nSTDERR: ...{}\nCoder Error: {:?}",
                    att.attempt_number,
                    att.verification_stdout.chars().rev().take(100).collect::<String>().chars().rev().collect::<String>(), // last 100 chars
                    att.verification_stderr.chars().rev().take(100).collect::<String>().chars().rev().collect::<String>(), // last 100 chars
                    att.llm_error_summary.as_deref().unwrap_or("N/A")
                )
            })
        } else { None };

        let baml_output: BamlCoderOutput = self.baml_client.execute_coding_task(
            &task.id, &task.description, &model_task_type_to_string(&task.task_type),
            relevant_code_context, relevant_crate_docs, previous_attempt_feedback.as_deref(),
        ).await.map_err(|e| {
            logs.push(self.log_entry(format!("{}BAML ExecuteCodingTask LLM call failed: {:?}", log_msg_prefix, e), LogLevel::Error, Some(task.id.clone()), None));
            AppError::Llm(format!("BAML ExecuteCodingTask: {:?}", e))
        })?;

        let coder_output_model = baml_coder_output_to_model(baml_output, task.id.clone());

        // Create and store the attempt record. Verification results will be added later by Planner.
        let attempt_record = TaskAttempt {
            attempt_number: attempt_num,
            code_generated_summary: Some(format!("{} files changed, {} docs changed.", coder_output_model.changed_files.len(), coder_output_model.generated_docs.len())),
            docs_generated_summary: None, // Could be more specific
            verification_stdout: "Pending verification".to_string(),
            verification_stderr: "Pending verification".to_string(),
            verification_exit_code: -999, // Sentinel for pending
            llm_error_summary: coder_output_model.error_message.clone(), // Error from LLM itself, if any
            coder_notes: coder_output_model.notes.clone(),
        };
        task.attempts.push(attempt_record);

        logs.push(self.log_entry(format!("{}BAML execution attempt finished. Coder success: {}", log_msg_prefix, coder_output_model.success), LogLevel::Info, Some(task.id.clone()), Some(serde_json::json!({"coder_notes": coder_output_model.notes}))));
        Ok((coder_output_model, logs))
    }
}
</file>

<file path="src-tauri/src/agents/mod.rs">
pub mod coder;
pub mod planner;
// pub mod qa_strategist; // Future
// pub mod documenter_agent; // Future
</file>

<file path="src-tauri/src/agents/planner.rs">
use crate::app_state::{AppServices, CurrentProjectSession};
use crate::baml_client::{BamlClient, BamlTaskOutput, BamlTaskType as BamlClientTaskType};
use crate::error::{AppError, Result as AppResult};
use crate::models::{
    CoderOutput, GlobalLogEntry, LogLevel, ProjectSettings, ProjectStatus, SpecFile, Task,
    TaskStatus, TaskType,
};
use crate::services::knowledge_manager::TantivySearchResultItem;
use parking_lot::Mutex;
use std::sync::Arc;
use uuid::Uuid;

// Helper to convert BAML TaskType to model TaskType
fn baml_task_type_to_model(baml_type: BamlClientTaskType) -> TaskType {
    /* ... as before ... */
    TaskType::ImplementFunction
}

pub struct PlannerAgent {
    services: Arc<AppServices>,
    baml_client: Arc<BamlClient>,
}

impl PlannerAgent {
    pub fn new(services: Arc<AppServices>, baml_client: Arc<BamlClient>) -> Self {
        Self {
            services,
            baml_client,
        }
    }

    fn log_entry(
        &self,
        message: String,
        level: LogLevel,
        task_id: Option<String>,
        details: Option<serde_json::Value>,
    ) -> GlobalLogEntry {
        GlobalLogEntry {
            id: Uuid::new_v4().to_string(),
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_millis() as u64,
            level,
            component: "PlannerAgent".to_string(),
            message,
            task_id,
            details,
        }
    }

    pub async fn prepare_context_for_coder(
        &self,
        task: &Task,
        project_path: &str,
        settings: &ProjectSettings,
    ) -> AppResult<(String, String, Vec<GlobalLogEntry>)> {
        // (code_ctx, crate_docs_ctx, logs)
        let mut logs = Vec::new();
        logs.push(self.log_entry(
            format!("Preparing BAML context for Coder, task: {}", task.id),
            LogLevel::Debug,
            Some(task.id.clone()),
            None,
            None,
        ));

        let workspace = self.services.workspace_service.lock();
        let knowledge_manager = self.services.knowledge_manager_service.lock(); // Tantivy is here

        let mut relevant_code_context_str = String::new();
        let mut relevant_crate_docs_str = String::new();

        // --- Intelligent Context Fetching using Tantivy ---
        // 1. Parse task.description for keywords, symbols, file names, crate names.
        // TODO: Implement NLP or regex for keyword extraction from task.description.
        let keywords_from_task = vec![task.task_type.to_string()]; // Basic: use task type as a keyword
                                                                   // Add more sophisticated keyword extraction here.

        if !keywords_from_task.is_empty() {
            let query = keywords_from_task.join(" OR "); // Example query construction

            // Search for relevant code files
            match knowledge_manager
                .search_index(&query, 3, Some("rust_code"), project_path)
                .await
            {
                Ok((code_results, search_logs)) => {
                    logs.extend(search_logs);
                    for item in code_results.iter().take(2) {
                        // Take top 2 code results
                        match workspace.read_file_from_project(project_path, &item.relative_path).await {
                            Ok(content) => relevant_code_context_str.push_str(&format!("\n--- Relevant Code File: {} (Score: {:.2}) ---\n```rust\n{}\n```\n", item.relative_path, item.score, content.chars().take(1500).collect::<String>())), // Limit content length
                            Err(e) => logs.push(self.log_entry(format!("CtxPrep: Failed to read {}: {:?}", item.relative_path, e), LogLevel::Warn, Some(task.id.clone()), None)),
                        }
                    }
                }
                Err(e) => logs.push(self.log_entry(
                    format!(
                        "CtxPrep: Tantivy code search failed for query '{}': {:?}",
                        query, e
                    ),
                    LogLevel::Error,
                    Some(task.id.clone()),
                    None,
                )),
            }

            // Search for relevant documentation (specs or codebase docs)
            match knowledge_manager
                .search_index(&query, 2, Some("code_doc"), project_path)
                .await
            {
                // Also search "spec_doc"
                Ok((doc_results, search_logs)) => {
                    logs.extend(search_logs);
                    for item in doc_results.iter().take(1) {
                        // Take top 1 doc result
                        match workspace
                            .read_file_from_project(project_path, &item.relative_path)
                            .await
                        {
                            Ok(content) => relevant_code_context_str.push_str(&format!(
                                "\n--- Relevant Documentation: {} (Score: {:.2}) ---\n{}\n",
                                item.relative_path,
                                item.score,
                                content.chars().take(1000).collect::<String>()
                            )),
                            Err(e) => logs.push(self.log_entry(
                                format!("CtxPrep: Failed to read {}: {:?}", item.relative_path, e),
                                LogLevel::Warn,
                                Some(task.id.clone()),
                                None,
                            )),
                        }
                    }
                }
                Err(e) => logs.push(self.log_entry(
                    format!(
                        "CtxPrep: Tantivy doc search failed for query '{}': {:?}",
                        query, e
                    ),
                    LogLevel::Error,
                    Some(task.id.clone()),
                    None,
                )),
            }
        }

        // TODO: Extract crate names mentioned in task.description and fetch their summaries
        // using knowledge_manager.get_crate_documentation_summary (which might itself use Tantivy if summaries are indexed)
        // and append to `relevant_crate_docs_str`.

        if relevant_code_context_str.is_empty() {
            relevant_code_context_str =
                "// No specific code context found by Tantivy for this task.".to_string();
        }
        if relevant_crate_docs_str.is_empty() {
            relevant_crate_docs_str =
                "// No specific crate documentation context identified for this task.".to_string();
        }

        logs.push(self.log_entry(
            "Context preparation with Tantivy completed.".into(),
            LogLevel::Debug,
            Some(task.id.clone()),
            Some(serde_json::json!({
                "code_ctx_len": relevant_code_context_str.len(),
                "crate_docs_ctx_len": relevant_crate_docs_str.len(),
            })),
        ));

        Ok((relevant_code_context_str, relevant_crate_docs_str, logs))
    }

    pub async fn analyze_and_decompose_spec(
        &self,
        spec_file: &SpecFile,
        project_session: &mut CurrentProjectSession,
        settings: &ProjectSettings,
    ) -> AppResult<Vec<GlobalLogEntry>> {
        let mut logs = Vec::new();
        logs.push(self.log_entry(
            format!("Starting BAML decomposition for spec: {}", spec_file.name),
            LogLevel::Info,
            None,
            None,
        ));
        // ... (fetch spec_content, architecture_content, file_index_content as before) ...
        let project_root = project_session
            .project_path
            .as_ref()
            .ok_or(AppError::Operation("Project path not set".into()))?;
        let workspace = self.services.workspace_service.lock();
        let spec_content = workspace
            .read_file_from_project(project_root, &spec_file.relative_path)
            .await?;
        let architecture_content = workspace
            .read_file_from_project(project_root, "docs/architecture.md")
            .await
            .unwrap_or_else(|_| "Not available.".to_string());
        let file_index_content = workspace
            .read_file_from_project(project_root, "docs/file-index.md")
            .await
            .unwrap_or_else(|_| "Not available.".to_string());

        let baml_tasks: Vec<BamlTaskOutput> = self
            .baml_client
            .decompose_specification(
                &spec_file.name,
                &spec_content,
                &architecture_content,
                &file_index_content,
            )
            .await
            .map_err(|e| {
                logs.push(self.log_entry(
                    format!("BAML DecomposeSpecification failed: {:?}", e),
                    LogLevel::Error,
                    None,
                    None,
                ));
                AppError::Llm(format!("BAML DecomposeSpecification: {:?}", e))
            })?;

        // TODO: Post-process baml_tasks:
        // 1. Validate IDs are unique.
        // 2. Build a proper parent_id hierarchy if BAML output is flat but implies hierarchy.
        // 3. Ensure all dependencies point to valid task IDs from the current decomposition.
        // 4. Convert to model_tasks as before.
        let model_tasks = baml_tasks
            .into_iter()
            .map(|bt| Task {
                id: bt.id,
                parent_id: bt.parent_id,
                description: bt.description,
                task_type: baml_task_type_to_model(bt.task_type),
                status: TaskStatus::Pending,
                context_summary: "Awaiting context preparation".into(),
                dependencies: bt.dependencies,
                sub_task_ids: vec![],
                attempts: vec![],
                current_attempt_number: 0,
                last_coder_output: None,
                human_review_notes: None,
            })
            .collect();

        project_session.tasks = model_tasks;
        project_session.status = ProjectStatus::ReadyToExecute;
        logs.push(self.log_entry(
            format!(
                "BAML decomposition complete. {} tasks created.",
                project_session.tasks.len()
            ),
            LogLevel::Info,
            None,
            None,
        ));
        Ok(logs)
    }

    pub async fn select_next_task<'a>(
        &self,
        project_session: &'a CurrentProjectSession,
    ) -> Option<&'a Task> {
        // TODO: Implement more sophisticated task selection:
        // - Prioritize tasks based on type (e.g., setup before implementation).
        // - Consider task readiness (Pending or Ready status).
        // - Ensure all dependencies are in CompletedSuccess status.
        project_session.tasks.iter().find(|task| {
            (task.status == TaskStatus::Pending || task.status == TaskStatus::Ready)
                && task.dependencies.iter().all(|dep_id| {
                    project_session
                        .tasks
                        .iter()
                        .find(|t| t.id == *dep_id)
                        .map_or(false, |t_dep| t_dep.status == TaskStatus::CompletedSuccess)
                })
        })
    }

    pub async fn prepare_context_for_coder(
        &self,
        task: &Task,
        project_path: &str,
        settings: &ProjectSettings,
    ) -> AppResult<(String, String, Vec<GlobalLogEntry>)> {
        // (code_ctx, crate_docs_ctx, logs)
        let mut logs = Vec::new();
        logs.push(self.log_entry(
            format!("Preparing BAML context for Coder, task: {}", task.id),
            LogLevel::Debug,
            Some(task.id.clone()),
            None,
        ));

        let workspace = self.services.workspace_service.lock();
        let knowledge_manager = self.services.knowledge_manager_service.lock();

        let mut relevant_code_context_str = String::new();
        let mut relevant_crate_docs_str = String::new();

        // TODO: Implement intelligent context fetching based on task.description and task.task_type:
        // 1. Parse task.description for file paths, function/struct names, crate names.
        // 2. Use WorkspaceService.search_code_with_sidecar_ripgrep for usages/definitions.
        // 3. Use WorkspaceService.read_file_from_project to get content of relevant files.
        // 4. Use KnowledgeManagerService.get_crate_documentation_summary for mentioned crates.
        // 5. Concatenate these into `relevant_code_context_str` and `relevant_crate_docs_str`.
        //    Be mindful of context window limits for the LLM. Summarize if necessary.
        relevant_code_context_str =
            "// Stub: Relevant code context would be fetched here.".to_string();
        relevant_crate_docs_str = "// Stub: Relevant crate docs would be fetched here.".to_string();
        logs.push(self.log_entry(
            "Context preparation stub executed.".into(),
            LogLevel::Debug,
            Some(task.id.clone()),
            None,
        ));

        Ok((relevant_code_context_str, relevant_crate_docs_str, logs))
    }

    pub async fn process_coder_output_and_verification(
        &self,
        task: &mut Task,
        coder_output: CoderOutput,
        verification_stdout: String,
        verification_stderr: String,
        verification_exit_code: i32,
        project_session: &mut CurrentProjectSession,
        settings: &ProjectSettings,
    ) -> AppResult<(TaskStatus, Vec<GlobalLogEntry>)> {
        let mut logs = Vec::new();
        let log_prefix = format!("[Task {} Att.{}] ", task.id, task.current_attempt_number);

        task.last_coder_output = Some(coder_output.clone()); // Store last output

        let mut current_task_status: TaskStatus;

        if !coder_output.success {
            current_task_status = TaskStatus::BlockedByError(
                coder_output
                    .error_message
                    .unwrap_or_else(|| "Coder marked as failed without specific error.".into()),
            );
            logs.push(self.log_entry(
                format!("{}Coder failed task: {:?}", log_prefix, current_task_status),
                LogLevel::Error,
                Some(task.id.clone()),
                None,
            ));
        } else if verification_exit_code != 0 {
            // TODO: Parse verification_stderr for specific errors to make status more informative
            current_task_status = TaskStatus::BlockedByError(format!(
                "Verification failed (code {}): {}",
                verification_exit_code,
                verification_stderr
                    .lines()
                    .take(5)
                    .collect::<Vec<_>>()
                    .join("\n")
            ));
            logs.push(self.log_entry(format!("{}Verification failed: {:?}", log_prefix, current_task_status), LogLevel::Warn, Some(task.id.clone()), Some(serde_json::json!({ "stdout": verification_stdout, "stderr": verification_stderr }))));
        } else {
            current_task_status = TaskStatus::CompletedSuccess;
            logs.push(self.log_entry(
                format!("{}Task successfully coded and verified.", log_prefix),
                LogLevel::Info,
                Some(task.id.clone()),
                None,
            ));
        }

        // Update task attempt record (assuming it was pushed by CoderAgent.execute_task before this call)
        if let Some(last_attempt) = task.attempts.last_mut() {
            last_attempt.verification_stdout = verification_stdout;
            last_attempt.verification_stderr = verification_stderr;
            last_attempt.verification_exit_code = verification_exit_code;
            if !matches!(current_task_status, TaskStatus::CompletedSuccess) {
                last_attempt.llm_error_summary = Some(format!("{:?}", current_task_status));
                // Or specific error from coder_output
            }
        }

        // Self-correction logic
        if !matches!(current_task_status, TaskStatus::CompletedSuccess)
            && task.current_attempt_number < settings.max_self_correction_attempts
        {
            logs.push(self.log_entry(
                format!(
                    "{}Attempting self-correction (attempt {}/{})",
                    log_prefix,
                    task.current_attempt_number + 1,
                    settings.max_self_correction_attempts
                ),
                LogLevel::Info,
                Some(task.id.clone()),
                None,
            ));
            project_session.status = ProjectStatus::SelfCorrecting(task.id.clone());
            // The task status itself remains BlockedByError, but the session status indicates self-correction is underway for this task.
            // The main loop will pick this task up again for the CoderAgent.
        } else if !matches!(current_task_status, TaskStatus::CompletedSuccess) {
            logs.push(self.log_entry(format!("{}Max self-correction attempts reached or coder indicated unrecoverable error. Task failed.", log_prefix), LogLevel::Error, Some(task.id.clone()), None));
            current_task_status = TaskStatus::Failed; // Final failure
            project_session.status = ProjectStatus::AwaitingHumanInput(format!(
                "Task {} failed after {} attempts. Needs review.",
                task.id, task.current_attempt_number
            ));
        }

        Ok((current_task_status, logs))
    }
}
</file>

<file path="src-tauri/src/app_state.rs">
use crate::agents::coder::CoderAgent;
use crate::agents::planner::PlannerAgent;
use crate::models::{CrateInfo, GlobalLogEntry, ProjectSettings, ProjectStatus, Task};
use crate::services::knowledge_manager::KnowledgeManagerService;
use crate::services::workspace::WorkspaceService;
use parking_lot::Mutex;
use std::sync::Arc;
// HumanInterfaceService is more about how commands interact with AppHandle, not stored directly here.
use crate::baml_client::BamlClient;
use crate::error::Result as AppResult; // For consistency

#[derive(Clone, Debug, Default)]
pub struct CurrentProjectSession {
    pub project_path: Option<String>,
    pub status: ProjectStatus,
    pub active_spec_file: Option<String>,
    pub tasks: Vec<Task>,
    pub current_task_id_executing: Option<String>, // Task currently in ExecutingTask state
    pub logs: Vec<GlobalLogEntry>,                 // Limited size buffer for recent logs
    pub known_crates: Vec<CrateInfo>,
}

pub struct AppServices {
    pub workspace_service: Arc<Mutex<WorkspaceService>>,
    pub knowledge_manager_service: Arc<Mutex<KnowledgeManagerService>>,
}

pub struct AppAgents {
    pub planner_agent: Arc<Mutex<PlannerAgent>>,
    pub coder_agent: Arc<Mutex<CoderAgent>>,
}

pub struct AppState {
    pub settings: Arc<Mutex<ProjectSettings>>,
    pub current_project_session: Arc<Mutex<CurrentProjectSession>>,
    pub services: Arc<AppServices>,
    pub agents: Arc<AppAgents>,
    pub baml_client: Arc<BamlClient>,
}

impl AppState {
    pub fn new() -> Self {
        let settings = Arc::new(Mutex::new(ProjectSettings::default())); // TODO: Load settings from disk

        let baml_client = Arc::new(BamlClient::new(
            settings.lock().llm_api_key.clone(),
            settings.lock().tier1_llm_model_alias.clone(),
            settings.lock().tier2_llm_model_alias.clone(),
        ));

        let workspace_service = Arc::new(Mutex::new(WorkspaceService::new()));
        let knowledge_manager_service = Arc::new(Mutex::new(KnowledgeManagerService::new(
            workspace_service.clone(),
            baml_client.clone(),
        )));

        let services = Arc::new(AppServices {
            workspace_service: workspace_service.clone(),
            knowledge_manager_service,
        });

        let agents = Arc::new(AppAgents {
            planner_agent: Arc::new(Mutex::new(PlannerAgent::new(
                services.clone(),
                baml_client.clone(),
            ))),
            coder_agent: Arc::new(Mutex::new(CoderAgent::new(
                services.clone(),
                baml_client.clone(),
            ))),
        });

        Self {
            settings,
            current_project_session: Arc::new(Mutex::new(CurrentProjectSession::default())),
            services,
            agents,
            baml_client,
        }
    }

    // Log adding will be handled by a utility function in main.rs using AppHandle
}
</file>

<file path="src-tauri/src/baml_client/mod.rs">
// This entire module will be auto-generated by the BAML CLI.
// This placeholder allows the rest of the code to compile.
// We will manually define the structs and functions needed for now.

use serde::{Deserialize, Serialize};
use crate::error::{AppError, Result as AppResult};

// --- Mirroring BAML Enums and Classes (Simplified) ---
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum BamlTaskType { DefineStruct, ImplementFunction, WriteUnitTest, WriteIntegrationTest, RefactorCode, UpdateDocumentation, SetupCrate, RunVerification, HumanReview }
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BamlTaskOutput { pub id: String, pub parent_id: Option<String>, pub description: String, pub task_type: BamlTaskType, pub dependencies: Vec<String> }
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum BamlFileAction { Created, Modified, Deleted }
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BamlChangedFileOutput { pub relative_path: String, pub content: String, pub action: BamlFileAction }
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct BamlCoderOutput { pub task_id: String, pub changed_files: Vec<BamlChangedFileOutput>, pub generated_docs: Vec<BamlChangedFileOutput>, pub notes: Option<String>, pub success: bool, pub error_message: Option<String> }

// --- Conceptual BAML Client ---
pub struct BamlClient {}
impl BamlClient {
    pub fn new(_api_key: Option<String>, _planner_alias: String, _coder_alias: String) -> Self { Self {} }
    pub async fn decompose_specification(&self, spec_name: &str, _spec_content: &str, _architecture_content: &str, _file_index_content: &str) -> AppResult<Vec<BamlTaskOutput>> {
        println!("[BAML STUB] DecomposeSpecification called for: {}", spec_name);
        Ok(vec![ BamlTaskOutput { id: uuid::Uuid::new_v4().to_string(), parent_id: None, description: "Stubbed: Define models".into(), task_type: BamlTaskType::DefineStruct, dependencies: vec![] }])
    }
    pub async fn execute_coding_task(&self, task_id: &str, _task_description: &str, _task_type: &str, _relevant_code_context: &str, _relevant_crate_docs: &str, _previous_attempt_feedback: Option<&str>) -> AppResult<BamlCoderOutput> {
        println!("[BAML STUB] ExecuteCodingTask called for: {}", task_id);
        Ok(BamlCoderOutput { task_id: task_id.to_string(), changed_files: vec![], generated_docs: vec![], notes: Some("Stubbed BAML Coder execution".into()), success: true, error_message: None })
    }
}
</file>

<file path="src-tauri/src/config.rs">
use crate::error::{Result as AppResult, AppError};
use serde::{Deserialize, Serialize};
use std::path::Path;

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(default)]
pub struct ProjectConfig {
    pub code_root: String,
    pub specs_dir: String,
    pub architecture_file: String,
    pub code_docs_dir: String,
    pub enabled_internal_tools: Vec<String>,
}

impl Default for ProjectConfig {
    fn default() -> Self {
        Self {
            code_root: ".".to_string(),
            specs_dir: "docs/specifications".to_string(),
            architecture_file: "docs/architecture.md".to_string(),
            code_docs_dir: "docs/code_documentation".to_string(),
            enabled_internal_tools: vec!["*".to_string()],
        }
    }
}

impl ProjectConfig {
    pub async fn load(project_root: &Path) -> AppResult<Self> {
        let config_path = project_root.join("cognito_pilot.toml");
        if !config_path.exists() {
            return Ok(ProjectConfig::default());
        }
        let content = tokio::fs::read_to_string(&config_path).await?;
        toml::from_str(&content).map_err(|e| AppError::Config(format!("Failed to parse cognito_pilot.toml: {}", e)))
    }
}
</file>

<file path="src-tauri/src/mcp_server/handler.rs">
use async_trait::async_trait;
use rust_mcp_sdk::mcp_server::ServerHandler;
use rust_mcp_sdk::schema::{CallToolError, CallToolRequest, CallToolResult, ListToolsRequest, ListToolsResult, RpcError};
use rust_mcp_sdk::McpServer;
use std::sync::Arc;
use crate::app_state::AppServices;
use crate::mcp_server::tools::InternalTools;
use crate::models::CoderOutput;

pub struct InternalMcpHandler {
    pub services: Arc<AppServices>,
    pub project_root: String,
}

#[async_trait]
impl ServerHandler for InternalMcpHandler {
    async fn handle_list_tools_request(&self, _request: ListToolsRequest, _runtime: &dyn McpServer) -> Result<ListToolsResult, RpcError> {
        Ok(ListToolsResult { tools: InternalTools::tools(), meta: None, next_cursor: None })
    }

    async fn handle_call_tool_request(&self, request: CallToolRequest, _runtime: &dyn McpServer) -> Result<CallToolResult, CallToolError> {
        let tool_call = InternalTools::try_from(request.params).map_err(|e| CallToolError::invalid_params(Some(e.to_string())))?;

        match tool_call {
            InternalTools::GetFileContentTool(params) => {
                let ws = self.services.workspace_service.lock();
                match ws.read_file_from_project(&self.project_root, ¶ms.relative_path).await {
                    Ok(content) => Ok(CallToolResult::json_content(serde_json::json!({ "content": content }), None)),
                    Err(e) => Err(CallToolError::internal_error(Some(e.to_string()))),
                }
            }
            InternalTools::ProjectSearchTool(params) => {
                let km = self.services.knowledge_manager_service.lock();
                match km.search_index(¶ms.query, params.limit.unwrap_or(10), params.doc_type_filter.as_deref(), &self.project_root).await {
                    Ok((results, _logs)) => Ok(CallToolResult::json_content(serde_json::to_value(results).unwrap_or_default(), None)),
                    Err(e) => Err(CallToolError::internal_error(Some(e.to_string()))),
                }
            }
            InternalTools::ApplyChangesTool(params) => {
                let ws = self.services.workspace_service.lock();
                let coder_output = CoderOutput {
                    task_id: "mcp_tool_call".to_string(),
                    changed_files: params.changes,
                    generated_docs: vec![],
                    notes: Some("Changes applied via ApplyChangesTool".to_string()),
                    success: true,
                    error_message: None,
                };
                match ws.apply_coder_output(&self.project_root, &coder_output).await {
                    Ok(_) => {
                        match ws.git_commit_changes(&self.project_root, ¶ms.commit_message, None).await {
                            Ok(_) => Ok(CallToolResult::text_content("Changes applied and committed successfully.".to_string(), None)),
                            Err(e) => Err(CallToolError::internal_error(Some(format!("Changes applied but commit failed: {}", e)))),
                        }
                    }
                    Err(e) => Err(CallToolError::internal_error(Some(e.to_string()))),
                }
            }
        }
    }
}
</file>

<file path="src-tauri/src/mcp_server/mcp_client_runtime.rs">
// This is a placeholder for the client logic that agents will use.
// In a real implementation, this would use the rust-mcp-sdk's client runtime.
use crate::error::{AppError, Result as AppResult};
use serde_json::Value;

pub struct McpClientService {
    // http_client: reqwest::Client,
    // internal_server_url: String,
}

impl McpClientService {
    pub fn new(_internal_server_port: u16) -> Self {
        Self {}
    }
    pub async fn call_tool(&self, tool_name: &str, _parameters: Value) -> AppResult<Value> {
        tracing::info!("[MCP Client STUB] Calling tool: {}", tool_name);
        // TODO: Implement the actual HTTP POST to the internal server and handle the SSE response.
        Ok(serde_json::json!({ "status": "Tool call stub executed." }))
    }
}
</file>

<file path="src-tauri/src/mcp_server/mod.rs">
pub mod handler;
pub mod runner;
pub mod tools;
</file>

<file path="src-tauri/src/mcp_server/runner.rs">
// Using the full version from our discussion
use crate::app_state::AppServices;
use crate::error::Result as AppResult;
use crate::mcp_server::handler::InternalMcpHandler;
use rust_mcp_sdk::mcp_server::{hyper_server, HyperServerOptions};
use rust_mcp_sdk::schema::{
    Implementation, InitializeResult, ServerCapabilities, ServerCapabilitiesTools,
    LATEST_PROTOCOL_VERSION,
};
use std::sync::Arc;

pub async fn start_internal_mcp_server(
    services: Arc<AppServices>,
    project_root: String,
    port: u16,
) -> AppResult<()> {
    let server_details = InitializeResult {
        /* ... */ server_info: Implementation::default(),
        capabilities: ServerCapabilities::default(),
        instructions: None,
        protocol_version: LATEST_PROTOCOL_VERSION.to_string(),
        ..Default::default()
    };
    let handler = InternalMcpHandler {
        services,
        project_root,
    };
    let server_options = HyperServerOptions {
        host: "127.0.0.1".to_string(),
        port,
        ..Default::default()
    };
    let server = hyper_server::create_server(server_details, handler, server_options);
    tracing::info!("Starting Internal MCP Tool Server on port {}...", port);
    server.start().await.map_err(|e| e.into())
}
</file>

<file path="src-tauri/src/mcp_server/tools.rs">
use rust_mcp_sdk::macros::{mcp_tool, tool_box, JsonSchema};
use serde::{Deserialize, Serialize};

#[mcp_tool(name = "get_file_content", description = "Reads the full content of a file at a given path relative to the project root.", read_only_hint = true)]
#[derive(Debug, Deserialize, Serialize, JsonSchema)]
pub struct GetFileContentTool {
    pub relative_path: String,
}

#[mcp_tool(name = "project_search", description = "Performs a full-text search across the project's codebase, documentation, and specs using Tantivy.", read_only_hint = true)]
#[derive(Debug, Deserialize, Serialize, JsonSchema)]
pub struct ProjectSearchTool {
    pub query: String,
    pub doc_type_filter: Option<String>,
    pub limit: Option<usize>,
}

#[mcp_tool(name = "apply_changes", description = "Applies a set of file changes (create, modify, delete) to the workspace and commits them with a message.", destructive_hint = true)]
#[derive(Debug, Deserialize, Serialize, JsonSchema)]
pub struct ApplyChangesTool {
    pub changes: Vec<crate::models::ChangedFileContent>,
    pub commit_message: String,
}

tool_box!(
    InternalTools,
    [GetFileContentTool, ProjectSearchTool, ApplyChangesTool]
);
</file>

<file path="src-tauri/src/scaffolder.rs">
use crate::error::Result as AppResult;
use std::fs;
use std::io::{self, Write};
use std::path::{Path, PathBuf}; // Use AppResult

// TODO: Implement create_dir_all_verbose and create_file_with_content_verbose as discussed previously.
fn create_dir_all_verbose(path: &Path) -> io::Result<()> {
    /* ... */
    Ok(())
}
fn create_file_with_content_verbose(path: &Path, content: &str) -> io::Result<()> {
    /* ... */
    Ok(())
}

pub fn scaffold_new_project(
    project_root: &Path,
    project_name: &str,
    is_lib: bool,
) -> AppResult<()> {
    // TODO: Implement the full scaffolding logic from our earlier detailed discussion.
    // This includes creating codebase/, codebase-docs/, docs/ with all subdirectories and placeholder files.
    // Ensure all fs operations are wrapped in AppResult or map errors to AppError::Io.
    println!(
        "[SCAFFOLD STUB] Scaffolding project {} (is_lib: {}) at {:?}",
        project_name, is_lib, project_root
    );
    create_dir_all_verbose(project_root)?; // Example of error propagation
    Ok(())
}
</file>

<file path="src-tauri/src/services/human_interface.rs">
use crate::error::{AppError, Result as AppResult};
use crate::models::{GlobalLogEntry, LogLevel};
use tauri::{AppHandle, Emitter, Manager}; // Manager for get_window
use uuid::Uuid;

// This service is more of a collection of utility functions that use AppHandle.
// It's not typically stored in AppState directly if methods need AppHandle.

pub async fn notify_frontend_user(
    app_handle: &AppHandle,
    event_name: &str,
    payload: impl serde::Serialize + Clone,
) -> AppResult<()> {
    app_handle.emit_filter(event_name, |_target| true, payload)?; // Emit to all webviews
    Ok(())
}

pub async fn send_log_to_frontend(
    app_handle: &AppHandle,
    component: String,
    level: LogLevel,
    message: String,
    task_id: Option<String>,
    details: Option<serde_json::Value>,
) -> AppResult<()> {
    let log_entry = GlobalLogEntry {
        id: Uuid::new_v4().to_string(),
        timestamp: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64,
        level,
        component,
        message,
        task_id,
        details,
    };
    // Note: AppState's internal log buffer should also be updated. This function is just for emitting.
    // The `log_and_emit` utility in main.rs handles both.
    app_handle.emit_filter("global-log-event", |_target| true, log_entry)?;
    Ok(())
}

pub async fn request_human_input_modal(
    app_handle: &AppHandle,
    task_id: String,
    prompt: String,
) -> AppResult<()> {
    // TODO:
    // 1. Emit an event like "human-input-request" to the frontend with { task_id, prompt }.
    // 2. Frontend shows a modal and captures input.
    // 3. Frontend calls a Tauri command like `submit_human_input(task_id, input_text)`.
    // 4. The Planner/System then needs to be unblocked, perhaps by checking a shared state or a channel
    //    that `submit_human_input` writes to. This is a complex async interaction.
    notify_frontend_user(
        app_handle,
        "human-input-request",
        serde_json::json!({ "taskId": task_id, "prompt": prompt }),
    )
    .await?;
    Err(AppError::HumanInputRequired { prompt }) // Signal that input is now awaited
}
</file>

<file path="src-tauri/src/services/knowledge_manager.rs">
use std::sync::Arc;
use parking_lot::Mutex;
use std::path::{Path, PathBuf};
use tantivy::collector::{TopDocs, Count};
use tantivy::query::QueryParser;
use tantivy::schema::*;
use tantivy::{doc, Index, IndexWriter, IndexReader, ReloadPolicy, DocAddress, Term};
use walkdir::WalkDir;
use crate::services::workspace::WorkspaceService; // To read files
use crate::models::{CrateInfo, GlobalLogEntry, LogLevel, ProjectSettings, Task};
use crate::error::{Result as AppResult, AppError};
use crate::baml_client::BamlClient;
use uuid::Uuid;

// --- Tantivy Schema Definition ---
// We'll define fields that are common across different document types.
const FIELD_ID: &str = "id"; // Relative path, unique identifier
const FIELD_PROJECT_ROOT: &str = "project_root";
const FIELD_DOC_TYPE: &str = "doc_type"; // "rust_code", "code_doc", "spec_doc", "crate_summary_doc"
const FIELD_TITLE: &str = "title"; // Filename or extracted H1
const FIELD_CONTENT: &str = "content"; // Full text content
const FIELD_SYMBOLS: &str = "symbols"; // For rust_code: function names, struct names, etc.
const FIELD_TAGS: &str = "tags"; // General tags/keywords
const FIELD_LAST_MODIFIED: &str = "last_modified"; // u64 timestamp

fn build_tantivy_schema() -> Schema {
    let mut schema_builder = Schema::builder();
    schema_builder.add_text_field(FIELD_ID, STRING | STORED); // Unique ID, path
    schema_builder.add_text_field(FIELD_PROJECT_ROOT, STRING | STORED);
    schema_builder.add_text_field(FIELD_DOC_TYPE, STRING | STORED | FAST); // Fast for filtering/faceting
    schema_builder.add_text_field(FIELD_TITLE, TEXT | STORED);
    schema_builder.add_text_field(FIELD_CONTENT, TEXT | STORED);
    schema_builder.add_text_field(FIELD_SYMBOLS, TEXT | STORED); // For code symbols
    schema_builder.add_text_field(FIELD_TAGS, TEXT | STORED | FAST); // For keywords
    schema_builder.add_u64_field(FIELD_LAST_MODIFIED, INDEXED | STORED | FAST);
    schema_builder.build()
}

// --- Rust Code Symbol Extraction (Conceptual) ---
fn extract_rust_symbols(code: &str) -> Vec<String> {
    let mut symbols = Vec::new();
    // TODO: Use `syn::parse_file` and a `syn::visit::Visit` implementation
    // to traverse the AST and extract names of functions, structs, enums, traits, impls.
    // For brevity, this is a placeholder.
    // Example:
    // if let Ok(syntax_tree) = syn::parse_file(code) {
    //     struct SymbolVisitor<'a> { symbols: &'a mut Vec<String> }
    //     impl<'ast, 'a> syn::visit::Visit<'ast> for SymbolVisitor<'a> {
    //         fn visit_item_fn(&mut self, i: &'ast syn::ItemFn) {
    //             self.symbols.push(i.sig.ident.to_string());
    //             syn::visit::visit_item_fn(self, i);
    //         }
    //         // ... visit other items like ItemStruct, ItemEnum, etc. ...
    //     }
    //     let mut visitor = SymbolVisitor { symbols: &mut symbols };
    //     visitor.visit_file(&syntax_tree);
    // }
    if code.contains("fn main") { symbols.push("main".to_string()); } // Very basic stub
    symbols
}


pub struct KnowledgeManagerService {
    workspace_service: Arc<Mutex<WorkspaceService>>,
    baml_client: Arc<BamlClient>,
    index: Option<Index>, // Tantivy index
    reader: Option<IndexReader>, // Tantivy reader
    schema: Schema,
    // current_project_root_for_index: Option<PathBuf>, // To know which project index is open
}

impl KnowledgeManagerService {
    pub fn new(workspace_service: Arc<Mutex<WorkspaceService>>, baml_client: Arc<BamlClient>) -> Self {
        Self {
            workspace_service,
            baml_client,
            index: None,
            reader: None,
            schema: build_tantivy_schema(),
            // current_project_root_for_index: None,
        }
    }

    fn log_entry(&self, message: String, level: LogLevel, details: Option<serde_json::Value>) -> GlobalLogEntry {
        GlobalLogEntry { id: Uuid::new_v4().to_string(), timestamp: std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap_or_default().as_millis() as u64, level, component: "KnowledgeManager".to_string(), message, task_id: None, details }
    }

    fn get_index_path(&self, project_root_str: &str) -> PathBuf {
        PathBuf::from(project_root_str).join(".cognito_pilot_index")
    }

    pub async fn open_or_create_index(&mut self, project_root_str: &str) -> AppResult<Vec<GlobalLogEntry>> {
        let mut logs = Vec::new();
        let index_path = self.get_index_path(project_root_str);
        logs.push(self.log_entry(format!("Opening/Creating Tantivy index at: {}", index_path.display()), LogLevel::Info, None));

        let index = if !index_path.exists() {
            std::fs::create_dir_all(&index_path).map_err(|e| AppError::Io(format!("Failed to create index dir: {}", e)))?;
            Index::create_in_dir(&index_path, self.schema.clone())?
        } else {
            Index::open_in_dir(&index_path).map_err(|e| AppError::Io(format!("Failed to open index: {}. Consider deleting the index directory if corrupted.", e)))?
        };

        let reader = index.reader_builder()
            .reload_policy(ReloadPolicy::OnCommit) // Or Manual
            .try_into()?;

        self.index = Some(index);
        self.reader = Some(reader);
        // self.current_project_root_for_index = Some(PathBuf::from(project_root_str));
        logs.push(self.log_entry("Tantivy index initialized successfully.".into(), LogLevel::Info, None));
        Ok(logs)
    }

    pub async fn add_document_to_index(
        &self, index_writer: &mut IndexWriter, project_root_str: &str, relative_path_str: &str, doc_type: &str, content: &str,
    ) -> AppResult<()> {
        let id_field = self.schema.get_field(FIELD_ID).unwrap();
        let project_root_field = self.schema.get_field(FIELD_PROJECT_ROOT).unwrap();
        let doc_type_field = self.schema.get_field(FIELD_DOC_TYPE).unwrap();
        let title_field = self.schema.get_field(FIELD_TITLE).unwrap();
        let content_field = self.schema.get_field(FIELD_CONTENT).unwrap();
        let symbols_field = self.schema.get_field(FIELD_SYMBOLS).unwrap();
        // let tags_field = self.schema.get_field(FIELD_TAGS).unwrap();
        let last_modified_field = self.schema.get_field(FIELD_LAST_MODIFIED).unwrap();

        // Delete existing document with the same ID (path) before adding new one
        let id_term = Term::from_field_text(id_field, relative_path_str);
        index_writer.delete_term(id_term);

        let mut doc = Document::default();
        doc.add_text(id_field, relative_path_str);
        doc.add_text(project_root_field, project_root_str);
        doc.add_text(doc_type_field, doc_type);
        doc.add_text(title_field, Path::new(relative_path_str).file_name().unwrap_or_default().to_string_lossy()); // Simple title
        doc.add_text(content_field, content);

        if doc_type == "rust_code" {
            let symbols = extract_rust_symbols(content);
            for symbol in symbols {
                doc.add_text(symbols_field, &symbol);
            }
        }
        // TODO: Add last_modified from file metadata
        // let metadata = tokio::fs::metadata(PathBuf::from(project_root_str).join(relative_path_str)).await?;
        // let modified_timestamp = metadata.modified()?.duration_since(std::time::UNIX_EPOCH).map_err(|_| AppError::Operation("Time error".into()))?.as_secs();
        // doc.add_u64(last_modified_field, modified_timestamp);


        index_writer.add_document(doc)?;
        Ok(())
    }

    pub async fn rebuild_full_index(&mut self, project_root_str: &str, settings: &ProjectSettings) -> AppResult<Vec<GlobalLogEntry>> {
        let mut logs = Vec::new();
        if self.index.is_none() || self.reader.is_none() {
            let init_logs = self.open_or_create_index(project_root_str).await?;
            logs.extend(init_logs);
        }
        let index = self.index.as_ref().ok_or(AppError::Operation("Index not initialized for rebuild".into()))?;
        let mut index_writer = index.writer(50_000_000)?; // 50MB heap for writer

        logs.push(self.log_entry(format!("Starting full index rebuild for project: {}", project_root_str), LogLevel::Info, None));
        let ws = self.workspace_service.lock();

        let paths_to_index = vec![
            (PathBuf::from(project_root_str).join("codebase"), "rust_code", vec!["rs"]),
            (PathBuf::from(project_root_str).join("codebase-docs"), "code_doc", vec!["md"]),
            (PathBuf::from(project_root_str).join("docs/specs"), "spec_doc", vec!["md"]),
            (PathBuf::from(project_root_str).join("docs/crate-docs"), "crate_summary_doc", vec!["md"]), // Local summaries
        ];

        for (dir_to_scan, doc_type, extensions) in paths_to_index {
            if !dir_to_scan.exists() {
                logs.push(self.log_entry(format!("Directory not found for indexing: {}, skipping.", dir_to_scan.display()), LogLevel::Warn, None));
                continue;
            }
            logs.push(self.log_entry(format!("Indexing directory: {} as type '{}'", dir_to_scan.display(), doc_type), LogLevel::Debug, None));
            for entry in WalkDir::new(dir_to_scan).into_iter().filter_map(|e| e.ok()) {
                if entry.file_type().is_file() {
                    let path = entry.path();
                    if let Some(ext_str) = path.extension().and_then(|e| e.to_str()) {
                        if extensions.contains(&ext_str) {
                            let relative_path = path.strip_prefix(project_root_str).unwrap_or(path); // Path relative to project root
                            match ws.read_file_from_project(project_root_str, &relative_path.to_string_lossy()).await {
                                Ok(content) => {
                                    if let Err(e) = self.add_document_to_index(&mut index_writer, project_root_str, &relative_path.to_string_lossy(), doc_type, &content).await {
                                        logs.push(self.log_entry(format!("Failed to index {}: {:?}", relative_path.display(), e), LogLevel::Error, None));
                                    }
                                }
                                Err(e) => {
                                    logs.push(self.log_entry(format!("Failed to read {} for indexing: {:?}", relative_path.display(), e), LogLevel::Error, None));
                                }
                            }
                        }
                    }
                }
            }
        }
        index_writer.commit()?;
        // self.reader.as_ref().unwrap().reload()?; // Reload reader after commit
        logs.push(self.log_entry("Full index rebuild completed.".into(), LogLevel::Info, None));
        Ok(logs)
    }

    pub async fn update_document_in_index(&mut self, project_root_str: &str, relative_path_str: &str, doc_type: &str) -> AppResult<Vec<GlobalLogEntry>> {
        let mut logs = Vec::new();
         if self.index.is_none() {
            let init_logs = self.open_or_create_index(project_root_str).await?;
            logs.extend(init_logs);
        }
        let index = self.index.as_ref().ok_or(AppError::Operation("Index not initialized for update".into()))?;
        let mut index_writer = index.writer(10_000_000)?; // Smaller heap for single update

        logs.push(self.log_entry(format!("Updating document in index: {}", relative_path_str), LogLevel::Debug, None));
        let ws = self.workspace_service.lock();
        match ws.read_file_from_project(project_root_str, relative_path_str).await {
            Ok(content) => {
                if let Err(e) = self.add_document_to_index(&mut index_writer, project_root_str, relative_path_str, doc_type, &content).await {
                    logs.push(self.log_entry(format!("Failed to update index for {}: {:?}", relative_path_str, e), LogLevel::Error, None));
                    return Err(e);
                }
            }
            Err(AppError::Io(_)) => { // File might have been deleted
                let id_field = self.schema.get_field(FIELD_ID).unwrap();
                let id_term = Term::from_field_text(id_field, relative_path_str);
                index_writer.delete_term(id_term);
                logs.push(self.log_entry(format!("Document deleted from index (file not found): {}", relative_path_str), LogLevel::Debug, None));
            }
            Err(e) => {
                logs.push(self.log_entry(format!("Failed to read {} for index update: {:?}", relative_path_str, e), LogLevel::Error, None));
                return Err(e);
            }
        }
        index_writer.commit()?;
        Ok(logs)
    }


    #[derive(Serialize, Deserialize, Debug)]
    pub struct TantivySearchResultItem {
        pub score: f32,
        pub relative_path: String,
        pub title: String,
        pub doc_type: String,
        pub snippet_html: Option<String>, // With highlighted terms
    }

    pub async fn search_index(
        &self, query_str: &str, limit: usize, doc_type_filter: Option<&str>, project_root_str: &str
    ) -> AppResult<(Vec<TantivySearchResultItem>, Vec<GlobalLogEntry>)> {
        let mut logs = Vec::new();
        if self.reader.is_none() {
            // Attempt to open index if not already open for this project
            // This assumes KM service might be long-lived but project context changes.
            // A better approach is to ensure open_or_create_index is called when project is loaded.
            let init_logs = self.open_or_create_index(project_root_str).await?; // Ensure index is open
            logs.extend(init_logs);
        }
        let reader = self.reader.as_ref().ok_or(AppError::Operation("Tantivy reader not available.".into()))?;
        reader.reload()?; // Ensure reader has latest commits

        let searcher = reader.searcher();
        let id_field = self.schema.get_field(FIELD_ID).unwrap();
        let title_field = self.schema.get_field(FIELD_TITLE).unwrap();
        let content_field = self.schema.get_field(FIELD_CONTENT).unwrap();
        let symbols_field = self.schema.get_field(FIELD_SYMBOLS).unwrap();
        let doc_type_f = self.schema.get_field(FIELD_DOC_TYPE).unwrap();

        // Default fields to search: title, content, symbols
        let default_search_fields = vec![title_field, content_field, symbols_field];
        let query_parser = QueryParser::for_index(self.index.as_ref().unwrap(), default_search_fields);

        let mut final_query_str = query_str.to_string();
        if let Some(dt_filter) = doc_type_filter {
            final_query_str = format!("({}) AND {}:\"{}\"", query_str, FIELD_DOC_TYPE, dt_filter);
        }

        let query = query_parser.parse_query(&final_query_str)
            .map_err(|e| AppError::Operation(format!("Failed to parse Tantivy query '{}': {}", final_query_str, e)))?;

        let top_docs = searcher.search(&query, &TopDocs::with_limit(limit))?;
        let mut results = Vec::new();

        for (score, doc_address) in top_docs {
            let retrieved_doc = searcher.doc(doc_address)?;
            let relative_path = retrieved_doc.get_first(id_field).and_then(|v| v.as_text()).unwrap_or("").to_string();
            let title = retrieved_doc.get_first(title_field).and_then(|v| v.as_text()).unwrap_or(&relative_path).to_string();
            let doc_type_val = retrieved_doc.get_first(doc_type_f).and_then(|v| v.as_text()).unwrap_or("unknown").to_string();

            // TODO: Generate snippet with highlighting
            // let mut snippet_generator = SnippetGenerator::create(&searcher, &*query, content_field)?;
            // let snippet = snippet_generator.snippet_from_doc(&retrieved_doc);
            // let snippet_html = snippet.to_html(); // This highlights terms

            results.push(TantivySearchResultItem {
                score, relative_path, title, doc_type: doc_type_val, snippet_html: None, // Some(snippet_html)
            });
        }
        logs.push(self.log_entry(format!("Tantivy search for '{}' yielded {} results.", query_str, results.len()), LogLevel::Debug, Some(serde_json::json!({"query": query_str, "filter": doc_type_filter, "limit": limit}))));
        Ok((results, logs))
    }

    // ... get_crate_documentation_summary, update_project_file_index, qualify_and_add_crate, get_known_crates ...
    // These would remain, but update_project_file_index might become less critical if Tantivy search is good.
    // qualify_and_add_crate would also add the crate summary to Tantivy index.
}
</file>

<file path="src-tauri/src/services/workspace.rs">
use crate::error::{AppError, Result as AppResult};
use crate::models::{ChangedFileContent, FileAction, GlobalLogEntry, LogLevel};
use std::io::{BufRead, BufReader};
use std::path::{Path, PathBuf};
use std::process::{Command as StdCommand, Stdio}; // Renamed to avoid conflict
use tauri::api::process::Command as TauriCommand; // For logging

pub struct WorkspaceService {
    current_project_root: Option<PathBuf>,
}

impl WorkspaceService {
    pub fn new() -> Self {
        Self {
            current_project_root: None,
        }
    }
    pub fn set_project_root(&mut self, path: PathBuf) -> AppResult<()> {
        /* ... as before ... */
        Ok(())
    }
    fn get_project_root(&self) -> AppResult<&PathBuf> {
        /* ... as before ... */
        Ok(self.current_project_root.as_ref().unwrap())
    }
    fn get_codebase_root(&self) -> AppResult<PathBuf> {
        Ok(self.get_project_root()?.join("codebase"))
    }
    fn get_codebase_docs_root(&self) -> AppResult<PathBuf> {
        Ok(self.get_project_root()?.join("codebase-docs"))
    }
    fn get_docs_root(&self) -> AppResult<PathBuf> {
        Ok(self.get_project_root()?.join("docs"))
    }

    pub async fn read_file_from_project(
        &self,
        project_root_str: &str,
        relative_path_from_project: &str,
    ) -> AppResult<String> {
        // TODO: Implement robust file reading, ensure path is within project_root_str.
        let full_path = PathBuf::from(project_root_str).join(relative_path_from_project);
        tokio::fs::read_to_string(&full_path)
            .await
            .map_err(|e| AppError::Io(format!("Read {}: {}", full_path.display(), e)))
    }

    pub async fn write_file_to_project(
        &self,
        project_root_str: &str,
        relative_path_from_project: &str,
        content: &str,
    ) -> AppResult<()> {
        // TODO: Implement robust file writing, ensure path is within project_root_str. Create parent dirs.
        let full_path = PathBuf::from(project_root_str).join(relative_path_from_project);
        if let Some(parent) = full_path.parent() {
            tokio::fs::create_dir_all(parent).await?;
        }
        tokio::fs::write(&full_path, content)
            .await
            .map_err(|e| AppError::Io(format!("Write {}: {}", full_path.display(), e)))
    }

    pub async fn apply_coder_output(
        &self,
        project_root_str: &str,
        coder_output: &crate::models::CoderOutput,
    ) -> AppResult<Vec<GlobalLogEntry>> {
        let mut logs = Vec::new();
        let project_root_path = PathBuf::from(project_root_str);

        for file_change in &coder_output.changed_files {
            let target_dir = self.get_codebase_root()?; // Assuming these are codebase changes
            let full_path = target_dir.join(&file_change.relative_path);
            // TODO: Implement applying file_change (Create, Modify, Delete) to full_path using tokio::fs.
            // Log each action.
            logs.push(GlobalLogEntry {
                id: Uuid::new_v4().to_string(),
                timestamp: 0,
                level: LogLevel::Debug,
                component: "WorkspaceService".into(),
                message: format!(
                    "Applying file change: {:?} to {}",
                    file_change.action,
                    full_path.display()
                ),
                task_id: Some(coder_output.task_id.clone()),
                details: None,
            });
            match file_change.action {
                FileAction::Created | FileAction::Modified => {
                    if let Some(parent) = full_path.parent() {
                        tokio::fs::create_dir_all(parent).await?;
                    }
                    tokio::fs::write(&full_path, &file_change.content).await?;
                }
                FileAction::Deleted => {
                    if full_path.exists() {
                        tokio::fs::remove_file(&full_path).await?;
                    }
                }
            }
        }
        for doc_change in &coder_output.generated_docs {
            let target_dir = self.get_codebase_docs_root()?;
            let full_path = target_dir.join(&doc_change.relative_path);
            // TODO: Implement applying doc_change to full_path.
            logs.push(GlobalLogEntry {
                id: Uuid::new_v4().to_string(),
                timestamp: 0,
                level: LogLevel::Debug,
                component: "WorkspaceService".into(),
                message: format!(
                    "Applying doc change: {:?} to {}",
                    doc_change.action,
                    full_path.display()
                ),
                task_id: Some(coder_output.task_id.clone()),
                details: None,
            });
            match doc_change.action {
                FileAction::Created | FileAction::Modified => {
                    if let Some(parent) = full_path.parent() {
                        tokio::fs::create_dir_all(parent).await?;
                    }
                    tokio::fs::write(&full_path, &doc_change.content).await?;
                }
                FileAction::Deleted => { /* ... */ }
            }
        }
        Ok(logs)
    }

    pub async fn run_verification_stage(
        &self,
        stage: &str,
        project_root_str: &str,
        emit_progress_fn: Arc<dyn Fn(String) + Send + Sync>,
    ) -> AppResult<(String, String, i32, Vec<GlobalLogEntry>)> {
        let mut logs = Vec::new();
        let codebase_root = PathBuf::from(project_root_str).join("codebase");
        let args: Vec<&str> = match stage {
            "fmt" => vec!["fmt", "--all", "--check"],
            "clippy" => vec![
                "clippy",
                "--all-targets",
                "--all-features",
                "--",
                "-D",
                "warnings",
            ],
            "test" => vec!["test", "--all-targets", "--all-features", "--no-fail-fast"],
            "check" => vec!["check", "--all-targets", "--all-features"],
            _ => {
                return Err(AppError::Operation(format!(
                    "Unknown verification stage: {}",
                    stage
                )))
            }
        };
        logs.push(GlobalLogEntry {
            id: Uuid::new_v4().to_string(),
            timestamp: 0,
            level: LogLevel::Debug,
            component: "WorkspaceService".into(),
            message: format!(
                "Running cargo {} at {}",
                args.join(" "),
                codebase_root.display()
            ),
            task_id: None,
            details: None,
        });

        // TODO: Implement robust async command execution with StdCommand or tokio::process::Command.
        // Capture stdout, stderr, exit_code. Stream output using emit_progress_fn.
        // This is a simplified blocking approach for demonstration.
        let process = StdCommand::new("cargo")
            .current_dir(&codebase_root)
            .args(&args)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(|e| AppError::Operation(format!("Failed to spawn cargo {:?}: {}", args, e)))?;

        let mut stdout_str = String::new();
        let mut stderr_str = String::new();
        // Reading stdout
        if let Some(stdout_pipe) = process.stdout {
            let reader = BufReader::new(stdout_pipe);
            for line_result in reader.lines() {
                if let Ok(line) = line_result {
                    emit_progress_fn(format!("[{}:stdout] {}", stage, line));
                    stdout_str.push_str(&line);
                    stdout_str.push('\n');
                }
            }
        }
        // Reading stderr
        if let Some(stderr_pipe) = process.stderr {
            let reader = BufReader::new(stderr_pipe);
            for line_result in reader.lines() {
                if let Ok(line) = line_result {
                    emit_progress_fn(format!("[{}:stderr] {}", stage, line));
                    stderr_str.push_str(&line);
                    stderr_str.push('\n');
                }
            }
        }
        let status = process
            .wait_with_output()
            .map_err(|e| AppError::Operation(format!("Cargo command failed to complete: {}", e)))?
            .status;

        Ok((stdout_str, stderr_str, status.code().unwrap_or(-1), logs))
    }

    pub async fn search_code_with_sidecar_ripgrep(
        &self,
        query: &str,
        file_pattern: Option<&str>,
        project_root_str: &str,
    ) -> AppResult<(String, Vec<GlobalLogEntry>)> {
        let mut logs = Vec::new();
        let codebase_root = PathBuf::from(project_root_str).join("codebase");
        // TODO: Implement ripgrep sidecar execution as detailed before.
        // Ensure `binaries/rg` is correctly configured in tauri.conf.json and bundled.
        // Capture JSON output from ripgrep.
        logs.push(GlobalLogEntry {
            id: Uuid::new_v4().to_string(),
            timestamp: 0,
            level: LogLevel::Debug,
            component: "WorkspaceService".into(),
            message: format!(
                "Running ripgrep sidecar with query: '{}', pattern: {:?}",
                query, file_pattern
            ),
            task_id: None,
            details: None,
        });

        let mut rg_args = vec![query.to_string(), ".".to_string(), "--json".to_string()];
        if let Some(pattern) = file_pattern {
            rg_args.extend_from_slice(&["-g".to_string(), pattern.to_string()]);
        }

        let (mut rx, mut child) = TauriCommand::new_sidecar("binaries/rg")?
            .args(rg_args)
            .current_dir(codebase_root)
            .spawn()?;
        let mut output_json_lines = Vec::new();
        // ... (ripgrep output collection logic as before) ...
        while let Some(event) = rx.recv().await {
            /* ... handle CommandEvent ... */
            if let tauri::api::process::CommandEvent::Stdout(line) = event {
                output_json_lines.push(line);
            }
        }
        let _status = child.wait().await?; // Ensure process finishes

        Ok((output_json_lines.join("\n"), logs))
    }

    pub async fn git_commit_changes(
        &self,
        project_root_str: &str,
        message: &str,
        task_id: Option<&str>,
    ) -> AppResult<Vec<GlobalLogEntry>> {
        let mut logs = Vec::new();
        let codebase_root = PathBuf::from(project_root_str).join("codebase"); // Commits usually happen in codebase
                                                                              // TODO: Implement `git add .` and `git commit -m "{message}"` in `codebase_root`.
                                                                              // Use StdCommand or tokio::process::Command.
        logs.push(GlobalLogEntry {
            id: Uuid::new_v4().to_string(),
            timestamp: 0,
            level: LogLevel::Info,
            component: "WorkspaceService".into(),
            message: format!("Git committing changes with message: {}", message),
            task_id: task_id.map(String::from),
            details: None,
        });
        Ok(logs)
    }
}
</file>

<file path="src/App.css">
.logo.vite:hover {
  filter: drop-shadow(0 0 2em #747bff);
}

.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafb);
}
:root {
  font-family: Inter, Avenir, Helvetica, Arial, sans-serif;
  font-size: 16px;
  line-height: 24px;
  font-weight: 400;

  color: #0f0f0f;
  background-color: #f6f6f6;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}

.container {
  margin: 0;
  padding-top: 10vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: 0.75s;
}

.logo.tauri:hover {
  filter: drop-shadow(0 0 2em #24c8db);
}

.row {
  display: flex;
  justify-content: center;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}

a:hover {
  color: #535bf2;
}

h1 {
  text-align: center;
}

input,
button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  color: #0f0f0f;
  background-color: #ffffff;
  transition: border-color 0.25s;
  box-shadow: 0 2px 2px rgba(0, 0, 0, 0.2);
}

button {
  cursor: pointer;
}

button:hover {
  border-color: #396cd8;
}
button:active {
  border-color: #396cd8;
  background-color: #e8e8e8;
}

input,
button {
  outline: none;
}

#greet-input {
  margin-right: 5px;
}

@media (prefers-color-scheme: dark) {
  :root {
    color: #f6f6f6;
    background-color: #2f2f2f;
  }

  a:hover {
    color: #24c8db;
  }

  input,
  button {
    color: #ffffff;
    background-color: #0f0f0f98;
  }
  button:active {
    background-color: #0f0f0f69;
  }
}
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/GlobalSearch.tsx">
import React, { useState } from "react";
import { tauriApi, TantivySearchResultItem } from "../utils/tauriApi";

const GlobalSearch: React.FC = () => {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState<TantivySearchResultItem[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSearch = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!query.trim()) return;
    setIsLoading(true);
    setError(null);
    try {
      const searchResults = await tauriApi.searchProjectGlobally(
        query,
        undefined,
        10,
      );
      setResults(searchResults);
    } catch (err: any) {
      setError(err.message || "Search failed");
      setResults([]);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="p-4 bg-gray-800 rounded-lg shadow mt-6">
      <h3 className="text-xl font-medium text-gray-200 mb-3">
        Global Project Search (Tantivy)
      </h3>
      <form onSubmit={handleSearch} className="flex gap-2 mb-4">
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Search codebase, docs, specs..."
          className="flex-grow p-2 rounded bg-gray-700 text-white border border-gray-600"
        />
        <button
          type="submit"
          disabled={isLoading}
          className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded"
        >
          {isLoading ? "Searching..." : "Search"}
        </button>
      </form>
      {error && <p className="text-red-400">{error}</p>}
      {results.length > 0 && (
        <ul className="space-y-2 max-h-96 overflow-y-auto">
          {results.map((item) => (
            <li
              key={item.relative_path + item.title}
              className="p-3 bg-gray-700 rounded"
            >
              <p className="font-semibold text-purple-400">
                {item.title}{" "}
                <span className="text-xs text-gray-500">
                  ({item.doc_type}, Score: {item.score.toFixed(2)})
                </span>
              </p>
              <p className="text-sm text-gray-300">{item.relative_path}</p>
              {item.snippet_html && (
                <div
                  className="text-xs text-gray-400 mt-1"
                  dangerouslySetInnerHTML={{ __html: item.snippet_html }}
                />
              )}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default GlobalSearch;
</file>

<file path="src/components/HumanInputDialog.tsx">
import React, { useState } from "react";

interface HumanInputDialogProps {
  taskId: string;
  prompt: string;
  onSubmit: (taskId: string, responseText: string) => void;
  onClose: () => void;
}

const HumanInputDialog: React.FC<HumanInputDialogProps> = ({
  taskId,
  prompt,
  onSubmit,
  onClose,
}) => {
  const [responseText, setResponseText] = useState("");

  const handleSubmit = () => {
    if (responseText.trim()) {
      onSubmit(taskId, responseText);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-lg">
        <h3 className="text-xl font-semibold text-yellow-400 mb-3">
          Human Input Required
        </h3>
        <p className="text-sm text-gray-300 mb-1">
          Task ID: <span className="font-mono">{taskId}</span>
        </p>
        <p className="text-gray-200 mb-4 whitespace-pre-wrap">{prompt}</p>
        <textarea
          value={responseText}
          onChange={(e) => setResponseText(e.target.value)}
          rows={5}
          className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:ring-indigo-500 focus:border-indigo-500 mb-4"
          placeholder="Your response or clarification..."
        />
        <div className="flex justify-end space-x-3">
          <button
            onClick={onClose}
            className="px-4 py-2 rounded bg-gray-600 hover:bg-gray-500 text-white"
          >
            Cancel / Later
          </button>
          <button
            onClick={handleSubmit}
            className="px-4 py-2 rounded bg-indigo-600 hover:bg-indigo-700 text-white font-semibold"
          >
            Submit Response
          </button>
        </div>
      </div>
    </div>
  );
};
export default HumanInputDialog;
</file>

<file path="src/components/KnowledgeBaseView.tsx">
import React from 'react';
import { CrateInfo } from '../utils/tauriApi';
import GlobalSearch from './GlobalSearch';

interface KnowledgeBaseViewProps {
    knownCrates: CrateInfo[];
}

const KnowledgeBaseView: React.FC<KnowledgeBaseViewProps> = ({ knownCrates }) => {
  // TODO: Implement UI for approving/rejecting crates and adding new ones for qualification.
  return (
    <div className="p-4 space-y-6">
      <h2 className="text-2xl font-semibold text-indigo-400">Knowledge Base</h2>
      
      <div className="bg-gray-800 p-6 rounded-lg shadow">
        <h3 className="text-xl font-medium text-gray-200 mb-4">Known Crates</h3>
        {knownCrates.length > 0 ? (
            <ul className="space-y-2">
                {knownCrates.map(crateInfo => (
                    <li key={crateInfo.name} className="p-3 bg-gray-700 rounded">
                        <p className="font-semibold text-white">{crateInfo.name}</p>
                        <p className="text-sm text-gray-400">Status: {crateInfo.approval_status}</p>
                    </li>
                ))}
            </ul>
        ) : (
            <p className="text-gray-400">No crates have been processed yet.</p>
        )}
      </div>

      <GlobalSearch />

      <div className="bg-gray-800 p-6 rounded-lg shadow">
        <h3 className="text-xl font-medium text-gray-200 mb-3">Architecture</h3>
        {/* TODO: Add a viewer for docs/architecture.md */}
        <p className="text-gray-400">Architecture document viewer will be here.</p>
      </div>
    </div>
  );
};

export default KnowledgeBaseView;
</file>

<file path="src/components/Nav.tsx">
import React from 'react';

export type ViewName = "Dashboard" | "Specs" | "Tasks" | "Knowledge" | "Terminal" | "Settings";

interface NavProps {
  setCurrentView: (view: ViewName) => void;
  currentView: ViewName;
}

const Nav: React.FC<NavProps> = ({ setCurrentView, currentView }) => {
  const views: ViewName[] = ["Dashboard", "Specs", "Tasks", "Knowledge", "Terminal", "Settings"];
  return (
    <nav className="bg-gray-800/50 backdrop-blur-sm p-4 text-white fixed top-0 left-0 h-full w-56 flex flex-col border-r border-gray-700">
      <div className="flex items-center mb-8">
        <div className="w-8 h-8 bg-indigo-500 rounded-lg mr-3"></div>
        <h1 className="text-xl font-bold text-gray-100">CognitoPilot</h1>
      </div>
      <ul className="flex-grow">
        {views.map(view => (
          <li key={view} className="mb-2">
            <button
              onClick={() => setCurrentView(view)}
              className={`w-full text-left px-3 py-2 rounded-md transition-colors duration-200 text-sm font-medium ${
                currentView === view
                  ? 'bg-indigo-600 text-white shadow-lg'
                  : 'text-gray-300 hover:bg-gray-700 hover:text-white'
              }`}
            >
              {view}
            </button>
          </li>
        ))}
      </ul>
      <div className="text-xs text-gray-500 mt-4">Version 0.1.0</div>
    </nav>
  );
};

export default Nav;
</file>

<file path="src/components/SettingsView.tsx">
import React from 'react';

const SettingsView: React.FC = () => {
  // TODO: Implement form fields and logic to load/save settings via tauriApi.
  return (
    <div className="p-4">
      <h2 className="text-2xl font-semibold mb-6 text-indigo-400">Settings</h2>
      <div className="space-y-6">
        <div className="bg-gray-800 p-6 rounded-lg shadow">
            <h3 className="text-xl font-medium text-gray-200 mb-3">AI Model Configuration</h3>
            <p className="text-gray-400">Configure Tier 1/Tier 2 model aliases and API keys here.</p>
        </div>
        <div className="bg-gray-800 p-6 rounded-lg shadow">
            <h3 className="text-xl font-medium text-gray-200 mb-3">Autonomy & Git</h3>
            <p className="text-gray-400">Set autonomy level, self-correction attempts, and Git commit strategy here.</p>
        </div>
        <div className="bg-gray-800 p-6 rounded-lg shadow">
            <h3 className="text-xl font-medium text-gray-200 mb-3">External MCP Servers</h3>
            <p className="text-gray-400">Manage connections to external tool servers here.</p>
        </div>
        <div className="bg-gray-800 p-6 rounded-lg shadow">
            <h3 className="text-xl font-medium text-gray-200 mb-3">Search Index</h3>
            {/* TODO: Add button to trigger tauriApi.rebuildProjectSearchIndex() */}
            <button className="mt-2 bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded">
                Rebuild Tantivy Index
            </button>
        </div>
      </div>
    </div>
  );
};

export default SettingsView;
</file>

<file path="src/components/SystemTerminalView.tsx">
import React, { useRef, useEffect } from "react";
import { GlobalLogEntry } from "../utils/tauriApi";

interface SystemTerminalViewProps {
  logs: GlobalLogEntry[];
  cargoStream: string[];
}

const SystemTerminalView: React.FC<SystemTerminalViewProps> = ({
  logs,
  cargoStream,
}) => {
  const logsEndRef = useRef<null | HTMLDivElement>(null);
  const cargoEndRef = useRef<null | HTMLDivElement>(null);

  useEffect(() => {
    logsEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [logs]);
  useEffect(() => {
    cargoEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [cargoStream]);

  const formatLog = (log: GlobalLogEntry) => {
    const date = new Date(log.timestamp).toLocaleTimeString();
    return `[${date}][${log.level}][${log.component}${log.task_id ? `:${log.task_id.substring(0, 8)}` : ""}] ${log.message}`;
  };

  return (
    <div className="p-4 h-full flex flex-col">
      <h2 className="text-2xl font-semibold mb-4 text-indigo-400">
        System Logs & Terminal
      </h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 flex-grow min-h-0">
        <div className="bg-gray-800 p-3 rounded shadow flex flex-col min-h-0">
          <h3 className="text-lg font-medium text-gray-300 mb-2">
            Main System Logs
          </h3>
          <pre className="text-xs text-gray-300 flex-grow overflow-y-auto whitespace-pre-wrap break-all">
            {logs.map((log) => (
              <div key={log.id}>{formatLog(log)}</div>
            ))}
            <div ref={logsEndRef} />
          </pre>
        </div>
        <div className="bg-gray-800 p-3 rounded shadow flex flex-col min-h-0">
          <h3 className="text-lg font-medium text-gray-300 mb-2">
            Cargo Stream
          </h3>
          <pre className="text-xs text-green-400 flex-grow overflow-y-auto whitespace-pre-wrap break-all">
            {cargoStream.join("\n")}
            <div ref={cargoEndRef} />
          </pre>
        </div>
      </div>
      {/* TODO: Input for diagnostic commands or ripgrep search */}
    </div>
  );
};
export default SystemTerminalView;
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  @apply bg-gray-900 text-gray-200 font-sans;
}

/* Custom scrollbar for a more modern look */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  background: #1f2937; /* gray-800 */
}
::-webkit-scrollbar-thumb {
  background: #4b5563; /* gray-600 */
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: #6b7280; /* gray-500 */
}
</file>

<file path="src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="TODO1.md">
**Rust Backend (`src-tauri/`):**

1.  **`error.rs`**:
    *   TODO: Ensure all potential error sources are mapped to `AppError` variants.
2.  **`models.rs`**:
    *   TODO: Finalize all fields for `ProjectSettings`, `Task`, `TaskAttempt`, `CoderOutput`, `CrateInfo`, `GlobalLogEntry`.
    *   TODO: Consider adding more specific `TaskType` variants.
    *   TODO: Add `details` field to `TaskAttempt` for richer error/success context.
3.  **`baml_client/mod.rs`**:
    *   TODO: This entire module needs to be **auto-generated by the BAML CLI** based on `.baml` files.
    *   TODO: Create actual `.baml` files (`planner_baml.baml`, `coder_baml.baml`) with robust prompt engineering for all LLM interactions.
    *   TODO: Configure `baml_options.json` with actual LLM client details (OpenAI, Anthropic, Gemini, etc.) and model aliases.
    *   TODO: Implement proper error handling and retries within the BAML function definitions or client configuration.
4.  **`app_state.rs`**:
    *   TODO: Implement loading `ProjectSettings` from a configuration file on disk (e.g., in app data directory or project root).
    *   TODO: Implement saving `ProjectSettings` to disk.
    *   TODO: Consider if `HumanInterfaceService` needs to be part of `AppServices` or if `AppHandle` is always passed.
5.  **`scaffolder.rs`**:
    *   TODO: Implement `create_dir_all_verbose` and `create_file_with_content_verbose` helpers.
    *   TODO: Implement the full project scaffolding logic as detailed in earlier discussions (creating all directories and placeholder files for `codebase`, `codebase-docs`, `docs`).
    *   TODO: Allow custom scaffold templates (e.g., from `ProjectSettings.project_scaffold_template_url`).
6.  **`agents/planner.rs`**:
    *   TODO: `analyze_and_decompose_spec`:
        *   Implement robust fetching of `architecture_content` and `file_index_content`.
        *   Implement the actual BAML call to `baml_client.decompose_specification`.
        *   Implement thorough post-processing of `BamlTaskOutput` to create valid, hierarchical `Task` models (validate IDs, dependencies, build parent/child relationships).
    *   TODO: `select_next_task`: Implement more sophisticated task selection logic (priority, readiness, considering `ProjectStatus::SelfCorrecting`).
    *   TODO: `prepare_context_for_coder`:
        *   Implement intelligent parsing of `task.description` to identify relevant files, functions, structs, crates.
        *   Use `WorkspaceService.search_code_with_sidecar_ripgrep` and `read_file_from_project` for code context.
        *   Use `KnowledgeManagerService.get_crate_documentation_summary` for crate context.
        *   Implement context summarization/chunking if total context exceeds LLM limits.
        *   Return distinct context pieces (`relevant_code_context`, `relevant_crate_docs`) for the BAML Coder function.
    *   TODO: `process_coder_output_and_verification`:
        *   Implement more detailed parsing of `verification_stderr` to provide better error messages for `TaskStatus::BlockedByError`.
        *   Refine self-correction logic: how does it decide to retry? Does it modify the task description for the Coder?
        *   Handle `ProjectStatus::AwaitingHumanInput` more gracefully if max retries are hit.
7.  **`agents/coder.rs`**:
    *   TODO: `execute_task`:
        *   Implement the actual BAML call to `baml_client.execute_coding_task`.
        *   Ensure `previous_attempt_feedback` is formatted effectively for the LLM.
        *   Ensure `BamlCoderOutput` is correctly mapped to `CoderOutput` model.
8.  **`services/workspace.rs`**:
    *   TODO: `read_file_from_project`, `write_file_to_project`: Add path validation to prevent escaping project root.
    *   TODO: `apply_coder_output`: Ensure robust handling of `FileAction::Deleted` for both code and docs.
    *   TODO: `run_verification_stage`:
        *   Replace simplified blocking `StdCommand` with `tokio::process::Command` or `tauri::api::process::Command` for true async execution and better output streaming.
        *   Make verification stages (`fmt`, `clippy`, `test`, `check`) configurable, possibly based on `TaskType`.
    *   TODO: `search_code_with_sidecar_ripgrep`:
        *   Ensure `binaries/rg` sidecar is correctly configured in `tauri.conf.json` and bundled for all target platforms.
        *   Implement robust parsing of `ripgrep`'s JSON output into a structured format.
        *   Handle cases where `ripgrep` finds no matches (exit code 1) gracefully.
    *   TODO: `git_commit_changes`: Implement actual `git add .` and `git commit -m "{message}"` using `StdCommand` or `tokio::process::Command` within the `codebase_root`. Handle Git not being installed or not being a repo.
    *   TODO: Add more Git operations: `git_init_if_needed`, `git_create_branch`, `git_push_to_remote`.
    *   TODO: Add file/directory listing functions.
9.  **`services/knowledge_manager.rs`**:
    *   TODO: `get_crate_documentation_summary`:
        *   Implement reading from local cache `docs/crate-docs/{crate_name}.md`.
        *   Implement RAG vector DB integration (requires choosing and setting up a vector DB).
        *   Implement fetching from docs.rs (HTTP GET, HTML parsing) and summarizing with a Tier 2 BAML call.
    *   TODO: `update_project_file_index`:
        *   Implement recursive directory scan of `codebase/`.
        *   Implement file summarization (heuristic or Tier 2 BAML call).
        *   Format and write the Markdown index.
    *   TODO: `qualify_and_add_crate`:
        *   Implement fetching metadata from `crates.io` API.
        *   Implement fetching docs/README from crate source or docs.rs.
        *   Use Tier 2 BAML call for documentation quality assessment and summary generation.
        *   Write summary to `docs/crate-docs/{crate_name}.md`.
        *   Update a manifest (e.g., `docs/crate-docs/manifest.json`) with `CrateInfo`.
    *   TODO: `get_known_crates`: Load from `docs/crate-docs/manifest.json` or by scanning `.md` files.
10. **`services/human_interface.rs`**:
    *   TODO: `request_human_input_modal`: Fully implement the async workflow for showing a modal on the frontend and receiving the response back in Rust, likely involving channels or a request/response pattern managed by the Planner/main loop.
11. **`main.rs`**:
    *   TODO: `load_settings`: Implement actual loading from disk.
    *   TODO: `save_settings`: Implement actual saving to disk.
    *   TODO: `initialize_project`: Validate project structure more thoroughly.
    *   TODO: `load_spec_files_from_project`: Implement actual file listing and preview generation using `WorkspaceService`.
    *   TODO: `start_full_processing_for_spec`: Ensure robust error handling and state transitions.
    *   TODO: `run_main_execution_loop`:
        *   Refine the main loop logic for robustness, especially around state transitions (`ProjectStatus`) and error handling.
        *   Implement a delay or event-driven mechanism if it's a persistent loop, rather than tight looping.
        *   Ensure `task_to_run.context_summary` is updated after `prepare_context_for_coder`.
        *   Handle the case where `prepare_context_for_coder` itself fails.
    *   TODO: `submit_human_response`: Implement logic to potentially modify task or create follow-up tasks based on human input.
    *   TODO: `get_crate_info_cmd`: Fetch full `CrateInfo` from `KnowledgeManagerService`.
    *   TODO: `approve_crate_cmd`: Update `CrateInfo.approval_status` and persist it.
    *   TODO: Implement robust logging throughout all commands using `log_to_state_and_emit`.
    *   TODO: `RunEvent::WindowEvent` and `RunEvent::ExitRequested`: Implement proper state saving and cleanup on app close/exit.
    *   TODO: Add more Tauri commands for all necessary frontend interactions (e.g., getting specific task details, getting crate list, managing settings).
    *   TODO: Tracing setup: Ensure it's configured optimally for development and release.

**React Frontend (`src/`):**

1.  **`utils/tauriApi.ts`**:
    *   TODO: Define comprehensive TypeScript interfaces for ALL Rust models (`ProjectSettings`, `CurrentProjectSession`, `Task`, `TaskAttempt`, `CoderOutput`, `SpecFile`, `CrateInfo`, `GlobalLogEntry`, enums, etc.) to ensure type safety.
    *   TODO: Add API functions for ALL Tauri commands defined in `main.rs`.
    *   TODO: Add more specific event listener functions (e.g., `listenToSessionStateChanges`, `listenToTaskUpdates`).
2.  **`App.tsx`**:
    *   TODO: Implement more robust state synchronization with the backend, possibly using a dedicated event like `session-state-update` from Rust instead of just polling or relying on log messages.
    *   TODO: Handle errors from `tauriApi` calls gracefully, displaying user-friendly messages.
3.  **`components/Dashboard.tsx`**:
    *   TODO: Display more detailed task statistics (In Progress, Blocked, etc.).
    *   TODO: Implement "Recent Activity Log" by filtering and displaying `sessionState.logs`.
    *   TODO: Implement "Alerts/Notifications Area" for critical issues or human input requests.
    *   TODO: Add a button to trigger `run_main_execution_loop` if the system is in a state like `ReadyToExecute` or `Idle` (with tasks).
4.  **`components/SpecsView.tsx`**:
    *   TODO: Implement the "Initialize Existing Project" UI and connect it to `tauriApi.initializeProject`.
    *   TODO: Implement the "Scaffold New Project" UI fully.
    *   TODO: Display spec loading errors more clearly.
    *   TODO: Add a proper Markdown editor/viewer for creating/editing spec content (e.g., using `react-markdown` and a simple textarea or a more advanced editor component).
5.  **`components/TaskProgressView.tsx`**:
    *   TODO: Implement hierarchical rendering of tasks if `parent_id` and `sub_task_ids` are used.
    *   TODO: On task click, show a modal or detail pane with:
        *   Full task description.
        *   `context_summary`.
        *   List of `TaskAttempt`s with their details (generated code summary, verification output, errors).
        *   `last_coder_output` (diffs of changed files).
    *   TODO: Add controls to manually retry a failed task (if appropriate), or flag for specific human review.
    *   TODO: Visually distinguish tasks that are part of a self-correction loop.
6.  **`components/KnowledgeBaseView.tsx`**:
    *   TODO: Implement UI for listing known crates (`sessionState.known_crates`).
    *   TODO: Allow users to request qualification for a new crate (input field + button calling a new Tauri command `qualify_new_crate_cmd`).
    *   TODO: Allow users to approve/reject pending crates (calling `approve_crate_cmd`).
    *   TODO: Display `CrateInfo` details (summary, version, status).
    *   TODO: Implement viewer for `docs/architecture.md` and `docs/file-index.md` (fetch content via Tauri command).
7.  **`components/SystemTerminalView.tsx`**:
    *   TODO: Add filtering options for logs (by level, component, task ID).
    *   TODO: Add search functionality within logs.
    *   TODO: Implement an input field for diagnostic commands (e.g., `search_codebase` via `tauriApi`).
8.  **`components/SettingsView.tsx`**:
    *   TODO: Create form fields for all `ProjectSettings` (LLM aliases, API key, autonomy level, Git strategy, max retries).
    *   TODO: Implement loading settings via `tauriApi.loadSettings` on mount.
    *   TODO: Implement saving settings via `tauriApi.saveSettings`.
9.  **`components/HumanInputDialog.tsx`**:
    *   TODO: Ensure it's displayed correctly when `humanInputRequest` state is set in `App.tsx`.
    *   TODO: Style it to be non-intrusive but clear.
10. **General Frontend**:
    *   TODO: Implement consistent error handling and user feedback (e.g., using toasts or a notification area).
    *   TODO: Add loading indicators for all async operations.
    *   TODO: Improve styling and UX across all components.
    *   TODO: Implement routing if the number of views grows significantly (e.g., using `react-router-dom`).
    *   TODO: Ensure all interactive elements are accessible.
    *   TODO: Add a "Code Review" view to display diffs from `CoderOutput.changed_files` more formally.

This list is extensive, reflecting the complexity of the system we've designed. Each `TODO` represents a significant piece of implementation work.
</file>

<file path="TODO2.md">
This GlobalSearch.tsx component would then be added to one of the main views, like the Dashboard or as a persistent search bar in the Nav or header.

Summary of Tantivy Integration:

KnowledgeManagerService now encapsulates Tantivy index creation, management, document addition/updating, and searching.

A Tantivy schema is defined for various document types.

Initial indexing (rebuild_full_index) scans project directories.

Incremental updates (update_document_in_index) are intended to be called after file modifications (e.g., by WorkspaceService.apply_coder_output or a file watcher).

PlannerAgent now uses Tantivy search results to gather more relevant context for the CoderAgent.

syn crate is conceptually included for extracting Rust symbols to enhance code searchability (implementation stubbed).

New Tauri commands (rebuild_project_search_index, search_project_globally) expose Tantivy functionality to the frontend.

A placeholder React component (GlobalSearch.tsx) demonstrates how the UI might interact with the Tantivy search.

This makes the system's internal knowledge retrieval much more powerful.

Consolidated TODO List (Including Tantivy)

Rust Backend (src-tauri/):

All previous TODOs remain relevant, plus:

services/knowledge_manager.rs (Tantivy Specific):

TODO: build_tantivy_schema: Finalize schema fields, consider tokenizers for different languages/content.

TODO: extract_rust_symbols: Fully implement using syn::visit::Visit to traverse AST and extract function, struct, enum, trait, impl names, and potentially comments or docstrings associated with them.

TODO: open_or_create_index: Ensure robust error handling for index corruption (e.g., offer to delete and rebuild).

TODO: add_document_to_index:

Implement extraction of last_modified timestamp from file metadata and add to Tantivy doc.

Implement title extraction for Markdown (e.g., first H1).

Implement tag extraction (e.g., from frontmatter in Markdown, or keywords from content).

TODO: rebuild_full_index: Optimize file reading and document processing for large projects. Consider parallelizing parts of the indexing if safe.

TODO: update_document_in_index: Ensure it's called correctly after WorkspaceService.apply_coder_output (this requires a notification mechanism or direct call).

TODO: search_index:

Implement SnippetGenerator to provide highlighted search snippets in results.

Allow more advanced query construction (e.g., field-specific queries, boolean operators) passed from UI or agents.

Consider adding faceting capabilities based on doc_type or tags.

TODO: get_crate_documentation_summary: If local summaries are indexed in Tantivy, query them here.

TODO: qualify_and_add_crate: After generating/fetching a crate summary, add it to the Tantivy index with doc_type: "crate_summary_doc".

agents/planner.rs (Tantivy Usage):

TODO: prepare_context_for_coder:

Implement sophisticated keyword/symbol extraction from task.description.

Construct meaningful Tantivy queries based on these extractions.

Handle and combine results from multiple Tantivy searches (e.g., for code, for docs).

Implement logic for summarizing or selecting snippets from Tantivy results to respect LLM context window limits.

main.rs (Tantivy Commands & Integration):

TODO: Ensure rebuild_project_search_index is exposed and can be called from UI (e.g., in Settings).

TODO: Ensure initialize_project triggers an initial rebuild_full_index or checks if index exists and is current.

TODO: After WorkspaceService.apply_coder_output successfully applies changes, ensure KnowledgeManagerService.update_document_in_index is called for each affected file. This might involve the run_main_execution_loop coordinating this call.

React Frontend (src/):

All previous frontend TODOs remain relevant, plus:

utils/tauriApi.ts:

TODO: Add TypeScript interface for TantivySearchResultItem matching the Rust struct.

TODO: Add API functions for rebuild_project_search_index and search_project_globally.

New Component GlobalSearch.tsx:

TODO: Integrate this component into the main UI (e.g., in Nav.tsx or Dashboard.tsx).

TODO: Allow selection of doc_type_filter in the UI.

TODO: Display snippet_html (if provided) using dangerouslySetInnerHTML.

TODO: Make search results clickable, e.g., opening the file or a preview.

Settings View (SettingsView.tsx):

TODO: Add a button to trigger tauriApi.rebuildProjectSearchIndex().

TODO: Display index status (e.g., last indexed time, number of documents - requires new Tauri commands).

This integration of Tantivy significantly elevates the system's capability to leverage its local knowledge base effectively.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// @ts-expect-error process is a nodejs global
const host = process.env.TAURI_DEV_HOST;

// https://vite.dev/config/
export default defineConfig(async () => ({
  plugins: [react()],

  // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
  //
  // 1. prevent Vite from obscuring rust errors
  clearScreen: false,
  // 2. tauri expects a fixed port, fail if that port is not available
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host
      ? {
          protocol: "ws",
          host,
          port: 1421,
        }
      : undefined,
    watch: {
      // 3. tell Vite to ignore watching `src-tauri`
      ignored: ["**/src-tauri/**"],
    },
  },
}));
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Capture</title>
  </head>

  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="src-tauri/capabilities/default.json">
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": [
    "main"
  ],
  "permissions": [
    "core:default",
    "opener:default",
    "fs:default",
    "shell:default"
  ]
}
</file>

<file path="src-tauri/src/error.rs">
use serde::Serialize;
use thiserror::Error;

#[derive(Debug, Error, Serialize, Clone)]
pub enum AppError {
    #[error("IO Error: {0}")]
    Io(String),
    #[error("Serialization Error: {0}")]
    Serialization(String),
    #[error("Tauri API Error: {0}")]
    Tauri(String),
    #[error("Agent Error (Agent: {agent}, Task: {task_id:?}): {message}")]
    Agent { agent: String, task_id: Option<String>, message: String },
    #[error("Service Error (Service: {service}): {message}")]
    Service { service: String, message: String },
    #[error("Configuration Error: {0}")]
    Config(String),
    #[error("Operation Error: {0}")]
    Operation(String),
    #[error("LLM/BAML Error: {0}")]
    Llm(String),
    #[error("Human Input Required: {prompt}")]
    HumanInputRequired { prompt: String },
    #[error("Resource Not Found: {resource_type} - {identifier}")]
    NotFound { resource_type: String, identifier: String },
    #[error("Verification Failed: {stage} - {details}")]
    Verification { stage: String, details: String },
    #[error("Task Dependency Error: Task {task_id} missing dependency {dependency_id}")]
    TaskDependency { task_id: String, dependency_id: String },
    #[error("Invalid State for Operation: Current state {current_state}, expected {expected_state} for {operation}")]
    InvalidState { current_state: String, expected_state: String, operation: String },
}

impl From<std::io::Error> for AppError { fn from(err: std::io::Error) -> Self { AppError::Io(err.to_string()) } }
impl From<serde_json::Error> for AppError { fn from(err: serde_json::Error) -> Self { AppError::Serialization(err.to_string()) } }
impl From<tauri::Error> for AppError { fn from(err: tauri::Error) -> Self { AppError::Tauri(err.to_string()) } }
impl From<reqwest::Error> for AppError { fn from(err: reqwest::Error) -> Self { AppError::Llm(format!("HTTP Client Error: {}", err)) } }
impl From<tantivy::TantivyError> for AppError { fn from(err: tantivy::TantivyError) -> Self { AppError::Service { service: "KnowledgeManager".into(), message: format!("Tantivy Error: {}", err) } } }
impl From<tantivy::query::QueryParserError> for AppError { fn from(err: tantivy::query::QueryParserError) -> Self { AppError::Service { service: "KnowledgeManager".into(), message: format!("Tantivy Query Parser Error: {}", err) } } }

pub type Result<T, E = AppError> = std::result::Result<T, E>;
</file>

<file path="src-tauri/src/lib.rs">
// Learn more about Tauri commands at https://tauri.app/develop/calling-rust/
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_shell::init())
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_opener::init())
        .invoke_handler(tauri::generate_handler![greet])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
</file>

<file path="src-tauri/src/models.rs">
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ProjectSettings {
    pub tier1_llm_model_alias: String,
    pub tier2_llm_model_alias: String,
    pub llm_api_key: Option<String>,
    pub autonomy_level: AutonomyLevel,
    pub git_commit_strategy: GitCommitStrategy,
    pub max_self_correction_attempts: u32,
}

#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq)]
pub enum AutonomyLevel { #[default] FullAutopilot, ApprovalCheckpoints, ManualStepThrough }
#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq)]
pub enum GitCommitStrategy { #[default] PerTask, PerFeature, Manual }

#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq)]
pub enum ProjectStatus {
    #[default] Unloaded, Idle, Planning, ReadyToExecute, ExecutingTask,
    AwaitingHumanInput(String), SelfCorrecting(String),
    Paused, Error(String), CompletedGoal,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum TaskStatus {
    Pending, Ready, InProgress, BlockedByDependency,
    BlockedByError(String), AwaitingHumanClarification,

    CompletedSuccess, CompletedWithWarnings, Failed,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct TaskAttempt {
    pub attempt_number: u32,
    pub code_generated_summary: Option<String>,
    pub verification_stdout: String,
    pub verification_stderr: String,
    pub verification_exit_code: i32,
    pub llm_error_summary: Option<String>,
    pub coder_notes: Option<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Task {
    pub id: String, pub parent_id: Option<String>, pub description: String,
    pub task_type: TaskType, pub status: TaskStatus, pub context_summary: String,
    pub dependencies: Vec<String>, pub sub_task_ids: Vec<String>,
    pub attempts: Vec<TaskAttempt>, pub current_attempt_number: u32,
    pub last_coder_output: Option<CoderOutput>,
    pub human_review_notes: Option<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum TaskType {
    AnalyzeSpec, DecomposeSpec, DefineStruct, ImplementFunction, WriteUnitTest,
    WriteIntegrationTest, WriteE2ETest, RefactorCode, UpdateFileDocumentation,
    UpdateCrateDocumentation, SetupNewCrate, RunVerificationStage, RequestHumanInput,
    GitCommit, GitPush, UpdateFileIndex, QualifyCrate,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct CoderOutput {
    pub task_id: String, pub changed_files: Vec<ChangedFileContent>,
    pub generated_docs: Vec<ChangedFileContent>,
    pub notes: Option<String>, pub success: bool, pub error_message: Option<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ChangedFileContent {
    pub relative_path: String, pub content: String, pub action: FileAction,
}
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum FileAction { Created, Modified, Deleted }

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SpecFile {
    pub name: String, pub relative_path: String,
    pub content_preview: String, pub status: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct CrateInfo {
    pub name: String, pub version: Option<String>,
    pub approval_status: CrateApprovalStatus,
    pub documentation_summary: Option<String>, pub source_url: Option<String>,
    pub last_qualified_at: Option<u64>,
}
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum CrateApprovalStatus { Pending, Approved, Rejected, NeedsManualReview }

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum LogLevel { Info, Warn, Error, Debug, AgentTrace, HumanInput, LLMTrace }

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct GlobalLogEntry {
    pub id: String, pub timestamp: u64, pub level: LogLevel, pub component: String,
    pub message: String, pub task_id: Option<String>, pub details: Option<serde_json::Value>,
}
</file>

<file path="src-tauri/tauri.conf.json">
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "tauri-mcp-client-coder",
  "version": "0.1.0",
  "identifier": "com.tauri-mcp-client-coder.app",
  "build": {
    "beforeDevCommand": "pnpm dev",
    "devUrl": "http://localhost:1420",
    "beforeBuildCommand": "pnpm build",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "label": "main",
        "title": "Tauri AI Studio Capture",
        "width": 1024,
        "height": 768,
        "url": "/" 
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ]
  }
}
</file>

<file path="src/components/Dashboard.tsx">
import React from 'react';
import { CurrentProjectSession, Task } from '../utils/tauriApi';

interface DashboardProps { sessionState: CurrentProjectSession | null; }

const StatCard: React.FC<{ title: string; value: string | number; colorClass: string }> = ({ title, value, colorClass }) => (
    <div className="bg-gray-800 p-5 rounded-lg shadow-md">
        <h3 className="text-md font-medium text-gray-400 mb-1">{title}</h3>
        <p className={`text-2xl font-bold ${colorClass}`}>{value}</p>
    </div>
);

const Dashboard: React.FC<DashboardProps> = ({ sessionState }) => {
  if (!sessionState) return <div className="text-center p-8 text-gray-400">Loading dashboard...</div>;

  const completedTasks = sessionState.tasks.filter((t: Task) => t.status === 'CompletedSuccess').length;
  const pendingTasks = sessionState.tasks.filter((t: Task) => t.status === 'Pending' || t.status === 'Ready').length;
  const failedTasks = sessionState.tasks.filter((t: Task) => t.status === 'Failed' || t.status.toString().startsWith('BlockedByError')).length;
  const inProgressTasks = sessionState.tasks.filter((t: Task) => t.status === 'InProgress' || sessionState.current_task_id_executing === t.id).length;

  return (
    <div className="p-4 space-y-8">
      <h2 className="text-3xl font-semibold text-gray-100">Mission Control</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <StatCard title="Project Path" value={sessionState.project_path || "No project loaded"} colorClass="text-green-400 text-lg break-all" />
        <StatCard title="System Status" value={typeof sessionState.status === 'string' ? sessionState.status : JSON.stringify(sessionState.status)} colorClass="text-yellow-400" />
        <StatCard title="Active Specification" value={sessionState.active_spec_file?.split('/').pop() || "None"} colorClass="text-cyan-400" />
      </div>

      <div className="bg-gray-800 p-6 rounded-lg shadow-md">
        <h3 className="text-xl font-semibold text-gray-200 mb-4">Task Progress</h3>
        <div className="flex justify-around text-center">
            <div><p className="text-3xl font-bold text-white">{sessionState.tasks.length}</p><p className="text-sm text-gray-400">Total</p></div>
            <div><p className="text-3xl font-bold text-green-500">{completedTasks}</p><p className="text-sm text-gray-400">Completed</p></div>
            <div><p className="text-3xl font-bold text-yellow-500">{inProgressTasks}</p><p className="text-sm text-gray-400">In Progress</p></div>
            <div><p className="text-3xl font-bold text-gray-500">{pendingTasks}</p><p className="text-sm text-gray-400">Pending</p></div>
            <div><p className="text-3xl font-bold text-red-500">{failedTasks}</p><p className="text-sm text-gray-400">Failed/Blocked</p></div>
        </div>
      </div>
    </div>
  );
};
export default Dashboard;
</file>

<file path="src/components/SpecsView.tsx">
import React, { useState, useEffect, useCallback } from 'react';
import { tauriApi, SpecFile as SpecFileType } from '../utils/tauriApi';

interface SpecsViewProps { refreshSessionState: () => void; }

const SpecsView: React.FC<SpecsViewProps> = ({ refreshSessionState }) => {
  const [specs, setSpecs] = useState<SpecFileType[]>([]);
  const [isLoadingSpecs, setIsLoadingSpecs] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [newProjectName, setNewProjectName] = useState('');
  const [basePath, setBasePath] = useState('');
  const [isScaffolding, setIsScaffolding] = useState(false);
  const [projectPathToLoad, setProjectPathToLoad] = useState('');
  const [isLoadingProject, setIsLoadingProject] = useState(false);

  const fetchSpecsForCurrentProject = useCallback(async () => {
    setIsLoadingSpecs(true); setError(null);
    try {
      const loadedSpecs = await tauriApi.loadSpecFiles();
      setSpecs(loadedSpecs);
    } catch (err: any) {
      setError(err.message || "Failed to load specs. Is a project active?");
      setSpecs([]);
    } finally { setIsLoadingSpecs(false); }
  }, []);

  useEffect(() => { fetchSpecsForCurrentProject(); }, [fetchSpecsForCurrentProject]);

  const handleScaffoldProject = async () => {
    if (!newProjectName.trim()) { setError("Project name cannot be empty."); return; }
    setIsScaffolding(true); setError(null);
    try {
        await tauriApi.scaffoldProject(newProjectName, basePath || undefined);
        refreshSessionState();
        fetchSpecsForCurrentProject();
        setNewProjectName(''); setBasePath('');
    } catch (err: any) { setError(err.message || "Scaffolding failed."); }
    finally { setIsScaffolding(false); }
  };

  const handleInitializeProject = async () => {
    if (!projectPathToLoad.trim()) { setError("Project path to load is empty."); return; }
    setIsLoadingProject(true); setError(null);
    try {
        await tauriApi.initializeProject(projectPathToLoad);
        refreshSessionState();
        fetchSpecsForCurrentProject();
        setProjectPathToLoad('');
    } catch (err: any) { setError(err.message || "Failed to initialize project."); }
    finally { setIsLoadingProject(false); }
  };

  const handleProcessSpec = async (specPath: string) => {
    setError(null);
    try {
        await tauriApi.startFullProcessingForSpec(specPath);
        refreshSessionState();
    } catch (err: any) { setError(err.message || "Failed to start spec processing."); }
  };

  return (
    <div className="p-4 space-y-8">
      <h2 className="text-3xl font-semibold text-gray-100">Project & Specifications</h2>
      {error && <div className="bg-red-500/20 border border-red-500 text-red-300 p-3 rounded-md">{error}</div>}

      <div className="grid md:grid-cols-2 gap-6">
        <div className="p-6 bg-gray-800 rounded-lg shadow-md">
          <h3 className="text-xl font-medium text-gray-200 mb-4">Initialize Existing Project</h3>
          <div className="flex gap-2">
            <input type="text" value={projectPathToLoad} onChange={(e) => setProjectPathToLoad(e.target.value)} placeholder="Enter absolute path to project" className="flex-grow p-2 rounded bg-gray-700 text-white border border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"/>
            <button onClick={handleInitializeProject} disabled={isLoadingProject} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">
              {isLoadingProject ? 'Loading...' : 'Load'}
            </button>
          </div>
        </div>
        <div className="p-6 bg-gray-800 rounded-lg shadow-md">
          <h3 className="text-xl font-medium text-gray-200 mb-4">Scaffold New Project</h3>
          <div className="space-y-3">
            <input type="text" value={newProjectName} onChange={(e) => setNewProjectName(e.target.value)} placeholder="New project name" className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"/>
            <input type="text" value={basePath} onChange={(e) => setBasePath(e.target.value)} placeholder="Optional: Base path (e.g., D:\\dev)" className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600"/>
            <button onClick={handleScaffoldProject} disabled={isScaffolding} className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed">
              {isScaffolding ? 'Scaffolding...' : 'Scaffold Project'}
            </button>
          </div>
        </div>
      </div>
      
      <div className="bg-gray-800 p-6 rounded-lg shadow-md">
        <h3 className="text-xl font-medium text-gray-200 mb-4">Available Specifications</h3>
        {isLoadingSpecs ? <p>Loading specifications...</p> : specs.length === 0 ? (
          <p className="text-gray-400">No specifications found. Load a project to see specs.</p>
        ) : (
          <ul className="space-y-3">
            {specs.map(spec => (
              <li key={spec.path} className="p-4 bg-gray-700/50 rounded-md shadow-sm flex justify-between items-center hover:bg-gray-700 transition-colors">
                <div>
                  <h4 className="font-semibold text-lg text-gray-100">{spec.name}</h4>
                  <p className="text-sm text-gray-400 truncate max-w-md" title={spec.content_preview}>{spec.content_preview}</p>
                  <p className="text-xs text-gray-500">Status: {spec.status}</p>
                </div>
                <button onClick={() => handleProcessSpec(spec.path)} className="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded text-sm">
                  Process Spec
                </button>
              </li>
            ))}
          </ul>
        )}
        <button onClick={fetchSpecsForCurrentProject} className="mt-4 bg-gray-600 hover:bg-gray-500 text-white py-2 px-3 rounded text-sm">Refresh Specs</button>
      </div>
    </div>
  );
};
export default SpecsView;
</file>

<file path="src/components/TaskProgressView.tsx">
import React from 'react';
import { Task as TaskType } from '../utils/tauriApi';

interface TaskProgressViewProps {
  tasks: TaskType[];
  currentExecutingTaskId?: string | null;
}

const TaskItem: React.FC<{ task: TaskType; level: number; isExecuting: boolean }> = ({ task, level, isExecuting }) => {
  // TODO: Implement collapsible sub-tasks
  // TODO: Show more details on click (description, attempts, logs related to this task)
  const statusColor = () => {
    if (isExecuting) return 'border-blue-500 animate-pulse';
    switch (task.status) {
      case 'CompletedSuccess': return 'border-green-500';
      case 'InProgress': return 'border-yellow-500'; // Should be covered by isExecuting
      case 'Failed':
      case 'BlockedByError': return 'border-red-500';
      case 'Pending':
      case 'Ready': return 'border-gray-600';
      default: return 'border-gray-500';
    }
  };

  const statusBgColor = () => {
    switch (task.status) {
        case 'CompletedSuccess': return 'bg-green-600 text-green-100';
        case 'InProgress': return 'bg-yellow-600 text-yellow-100';
        case 'Failed':
        case 'BlockedByError': return 'bg-red-600 text-red-100';
        default: return 'bg-gray-500 text-gray-100';
    }
  }

  return (
    <div style={{ marginLeft: `${level * 20}px` }} className={`mb-2 p-3 bg-gray-800 rounded border-l-4 ${statusColor()}`}>
      <div className="flex justify-between items-center">
        <span className="font-medium text-white text-sm">{task.description.substring(0,100)}{task.description.length > 100 ? '...' : ''}</span>
        <span className={`px-2 py-0.5 text-xs rounded-full ${statusBgColor()}`}>
          {task.status.toString().startsWith('BlockedByError') ? 'Blocked' : task.status.toString()}
        </span>
      </div>
      <p className="text-xs text-gray-500 mt-1">ID: {task.id} | Type: {task.task_type.toString()} | Attempts: {task.current_attempt_number}</p>
      {/* TODO: Show sub_tasks recursively if task.sub_task_ids is populated and tasks are fetched hierarchically or flattened with parent_id */}
    </div>
  );
};

const TaskProgressView: React.FC<TaskProgressViewProps> = ({ tasks, currentExecutingTaskId }) => {
  // TODO: Implement hierarchical rendering if tasks have parent_id and sub_task_ids
  // For now, assumes a flat list or tasks are already nested in the data structure.
  return (
    <div className="p-4">
      <h2 className="text-2xl font-semibold mb-6 text-indigo-400">Task Progress</h2>
      {/* TODO: Add controls to trigger run_main_execution_loop if system is Paused/Idle */}
      {tasks.length === 0 ? (
        <p className="text-gray-400">No tasks planned yet. Process a specification to see tasks here.</p>
      ) : (
        <div className="space-y-3">
          {tasks.map(task => (
            <TaskItem key={task.id} task={task} level={0} isExecuting={task.id === currentExecutingTaskId} />
          ))}
        </div>
      )}
    </div>
  );
};

export default TaskProgressView;
</file>

<file path="src/utils/tauriApi.ts">
import { invoke } from "@tauri-apps/api/core";
import {
  listen,
  type EventCallback,
  type UnlistenFn,
} from "@tauri-apps/api/event";

// --- Replicated Rust Models (ensure these match Rust exactly) ---
// TODO: Manually define these interfaces to match the Rust structs in `models.rs`
export interface ProjectSettings {
  [key: string]: any;
}
export interface CurrentProjectSession {
  [key: string]: any;
}
export interface Task {
  [key: string]: any;
}
export interface SpecFile {
  [key: string]: any;
}
export interface CrateInfo {
  [key: string]: any;
}
export interface GlobalLogEntry {
  id: string;
  timestamp: number;
  level: string;
  component: string;
  message: string;
  task_id?: string;
  details?: any;
}
export interface TantivySearchResultItem {
  score: number;
  relative_path: string;
  title: string;
  doc_type: string;
  snippet_html?: string;
}
// --- End Replicated Rust Models ---

export const tauriApi = {
  loadSettings: (): Promise<ProjectSettings> => invoke("load_settings"),
  saveSettings: (settings: ProjectSettings): Promise<void> =>
    invoke("save_settings", { settings }),
  initializeProject: (projectPathStr: string): Promise<void> =>
    invoke("initialize_project", { projectPathStr }),
  scaffoldProject: (
    projectName: string,
    basePathStr?: string,
    isLib?: boolean,
  ): Promise<string> =>
    invoke("scaffold_project_cmd", { projectName, basePathStr, isLib }),
  getCurrentSessionState: (): Promise<CurrentProjectSession> =>
    invoke("get_current_session_state"),
  loadSpecFiles: (): Promise<SpecFile[]> =>
    invoke("load_spec_files_from_project"),
  startFullProcessingForSpec: (specRelativePath: string): Promise<void> =>
    invoke("start_full_processing_for_spec", { specRelativePath }),
  submitHumanResponse: (taskId: string, responseText: string): Promise<void> =>
    invoke("submit_human_response", { taskId, responseText }),
  getCrateInfo: (crateName: string): Promise<CrateInfo | null> =>
    invoke("get_crate_info_cmd", { crateName }),
  approveCrate: (crateName: string): Promise<void> =>
    invoke("approve_crate_cmd", { crateName }),
  rebuildProjectSearchIndex: (): Promise<void> =>
    invoke("rebuild_project_search_index"),
  searchProjectGlobally: (
    query: string,
    docTypeFilter?: string,
    limit?: number,
  ): Promise<TantivySearchResultItem[]> =>
    invoke("search_project_globally", { query, docTypeFilter, limit }),
};

export async function listenToGlobalLogEvents(
  handler: EventCallback<GlobalLogEntry>,
): Promise<UnlistenFn> {
  return await listen("global-log-event", handler);
}
export async function listenToCargoStreamEvents(
  handler: EventCallback<string>,
): Promise<UnlistenFn> {
  return await listen("cargo-stream", handler);
}
export async function listenToHumanInputRequestEvents(
  handler: EventCallback<{ taskId: string; prompt: string }>,
): Promise<UnlistenFn> {
  return await listen("human-input-request", handler);
}
</file>

<file path="package.json">
{
  "name": "tauri-mcp-client-coder",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "tauri": "tauri"
  },
  "dependencies": {
    "@tauri-apps/api": "^2",
    "@tauri-apps/plugin-fs": "~2.3.0",
    "@tauri-apps/plugin-opener": "^2",
    "@tauri-apps/plugin-shell": "~2.2.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.8",
    "@tauri-apps/cli": "^2",
    "@types/react": "^18.3.1",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.4",
    "tailwindcss": "^4.1.8",
    "typescript": "~5.6.2",
    "vite": "6.3.5"
  }
}
</file>

<file path="src-tauri/Cargo.toml">
[package]
name = "tauri-mcp-client-coder"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
# The `_lib` suffix may seem redundant but it is necessary
# to make the lib name unique and wouldn't conflict with the bin name.
# This seems to be only an issue on Windows, see https://github.com/rust-lang/cargo/issues/8519
name = "tauri_mcp_client_coder_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2.5.1", features = [] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tauri-plugin-fs = "2"
tauri-plugin-shell = "2"
tauri-plugin-dialog = "2"
tauri-plugin-clipboard = "2"

thiserror = "1.0"
parking_lot = "0.12"
uuid = { version = "1.6", features = ["v4", "serde"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = [
    "env-filter",
    "json",
] } # For structured logging

reqwest = { version = "0.12", features = [
    "json",
    "rustls-tls",
], default-features = false }
tantivy = "0.22" # Check for latest version
syn = { version = "2.0", features = [
    "full",
    "parsing",
    "visit",
] } # For parsing Rust code
walkdir = "2" # For recursively finding files to index
toml = "0.8"
lazy_static = "1.4"
async-trait = "0.1"


# --- MCP SDK Integration ---
# This will be used for the internal tool server.
rust-mcp-sdk = { version = "0.4.2", default-features = false, features = [
    "server",
    "macros",
    "hyper-server",
    "ssl",
    "2025_03_26",
] }
rust-mcp-schema = { version = "0.5", default-features = false, features = [
    "2025_03_26",
    "schema_utils",
] }

# --- BAML Client (as a path dependency) ---
# This assumes a `baml_client` directory will be created next to `src`
# baml-client = { path = "../baml_client" } # We will stub this for now
</file>

<file path="src-tauri/src/main.rs">
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

// --- Module Declarations ---
mod agents;
mod app_state;
mod baml_client;
mod config;
mod error;
mod mcp_client_runtime;
mod mcp_server;
mod models;
mod scaffolder;
mod services;

// --- Imports ---
use app_state::AppState;
use error::{AppError, Result as AppResult};
use models::*;
use services::human_interface as HumanIF;
use services::knowledge_manager::TantivySearchResultItem;

use std::path::PathBuf;
use std::sync::Arc;
use tauri::{AppHandle, Emitter, Manager, RunEvent, State, WindowEvent, Wry};
use uuid::Uuid;

// --- Utility to add log to state and emit event ---
fn log_to_state_and_emit(
    app_handle: &AppHandle,
    app_state: &State<AppState>,
    component: String,
    level: LogLevel,
    message: String,
    task_id: Option<String>,
    details: Option<serde_json::Value>,
) -> AppResult<()> {
    let entry = GlobalLogEntry {
        id: Uuid::new_v4().to_string(),
        timestamp: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64,
        level,
        component,
        message,
        task_id,
        details,
    };
    let payload_clone = entry.clone();
    {
        // Scope for session lock
        let mut session = app_state.current_project_session.lock();
        if session.logs.len() > 200 {
            session.logs.remove(0);
        } // Keep log buffer manageable
        session.logs.push(entry);
    }
    app_handle.emit_filter("global-log-event", |_t| true, payload_clone)?;
    Ok(())
}

// --- Tauri Commands ---

#[tauri::command]
async fn load_settings(app_state: State<'_, AppState>) -> AppResult<ProjectSettings> {
    // TODO: Load settings from a config file (e.g., project_root/cognito_pilot_settings.json or app data dir)
    // For now, returns default or current in-memory settings.
    Ok(app_state.settings.lock().clone())
}

#[tauri::command]
async fn save_settings(
    settings: ProjectSettings,
    app_state: State<'_, AppState>,
    app_handle: AppHandle,
) -> AppResult<()> {
    // TODO: Save settings to a config file.
    *app_state.settings.lock() = settings.clone();
    log_to_state_and_emit(
        &app_handle,
        &app_state,
        "System".into(),
        LogLevel::Info,
        "Settings saved.".into(),
        None,
        Some(serde_json::to_value(settings)?),
    )?;
    Ok(())
}

#[tauri::command]
async fn initialize_project(
    project_path_str: String,
    app_handle: AppHandle,
    app_state: State<'_, AppState>,
) -> AppResult<()> {
    // ... (Implementation from before, using log_to_state_and_emit) ...
    let path = PathBuf::from(&project_path_str);
    if !path.is_dir() || !path.join("codebase").is_dir() || !path.join("docs").is_dir() { /* ... error ... */
    }
    app_state
        .services
        .workspace_service
        .lock()
        .set_project_root(path.clone())?;
    {
        let mut session = app_state.current_project_session.lock();
        session.project_path = Some(project_path_str.clone());
        session.status = ProjectStatus::Idle;
        session.tasks.clear();
        session.logs.clear();
    }
    log_to_state_and_emit(
        &app_handle,
        &app_state,
        "System".into(),
        LogLevel::Info,
        format!("Project initialized: {}", project_path_str),
        None,
        None,
    )?;

    let km_clone = app_state.services.knowledge_manager_service.clone();
    let settings_clone = app_state.settings.lock().clone(); // Clone settings for async block
    tauri::async_runtime::spawn(async move {
        // TODO: Handle error from update_project_file_index by emitting a log event
        let _ = km_clone
            .lock()
            .update_project_file_index(&project_path_str, &settings_clone)
            .await;
    });
    Ok(())
}

#[tauri::command]
async fn scaffold_project_cmd(
    project_name: String,
    base_path_str: Option<String>,
    is_lib: bool,
    app_handle: AppHandle,
    app_state: State<'_, AppState>,
) -> AppResult<String> {
    // ... (Implementation from before, using log_to_state_and_emit and calling initialize_project) ...
    let root_dir = base_path_str.map_or_else(
        || std::env::current_dir().unwrap_or_default(),
        PathBuf::from,
    );
    let project_target_path = root_dir.join(&project_name);
    if project_target_path.exists() { /* ... error ... */ }
    scaffolder::scaffold_new_project(&project_target_path, &project_name, is_lib)?;
    let success_msg = format!(
        "Project '{}' scaffolded at '{}'",
        project_name,
        project_target_path.display()
    );
    log_to_state_and_emit(
        &app_handle,
        &app_state,
        "Scaffolder".into(),
        LogLevel::Info,
        success_msg.clone(),
        None,
        None,
    )?;
    initialize_project(
        project_target_path.to_string_lossy().into_owned(),
        app_handle.clone(),
        app_state.clone(),
    )
    .await?;
    Ok(success_msg)
}

#[tauri::command]
async fn get_current_session_state(
    app_state: State<'_, AppState>,
) -> AppResult<CurrentProjectSession> {
    Ok(app_state.current_project_session.lock().clone())
}

#[tauri::command]
async fn load_spec_files_from_project(app_state: State<'_, AppState>) -> AppResult<Vec<SpecFile>> {
    // TODO: Use WorkspaceService to list files in `project_root/docs/specs`, read previews.
    Ok(vec![SpecFile {
        name: "example_spec.md".into(),
        relative_path: "docs/specs/example_spec.md".into(),
        content_preview: "Stub: This is an example spec...".into(),
        status: "Pending".into(),
    }])
}

#[tauri::command]
async fn start_full_processing_for_spec(
    spec_relative_path: String,
    app_handle: AppHandle,
    app_state: State<'_, AppState>,
) -> AppResult<()> {
    let spec_file_model = SpecFile {
        /* ... create from spec_relative_path ... */ name: "stub".into(),
        relative_path: spec_relative_path,
        content_preview: "".into(),
        status: "Planning".into(),
    };
    let settings_clone = app_state.settings.lock().clone(); // Clone for async block

    {
        // Scope for session lock
        let mut session = app_state.current_project_session.lock();
        if session.project_path.is_none() {
            return Err(AppError::Config("No project loaded.".into()));
        }
        if !matches!(
            session.status,
            ProjectStatus::Idle | ProjectStatus::CompletedGoal | ProjectStatus::Error(_)
        ) {
            return Err(AppError::InvalidState {
                current_state: format!("{:?}", session.status),
                expected_state: "Idle/CompletedGoal/Error".into(),
                operation: "start_processing_spec".into(),
            });
        }
        session.status = ProjectStatus::Planning;
        session.active_spec_file = Some(spec_file_model.relative_path.clone());
        session.tasks.clear(); // Clear previous tasks
    }
    log_to_state_and_emit(
        &app_handle,
        &app_state,
        "System".into(),
        LogLevel::Info,
        format!("Starting processing for spec: {}", spec_file_model.name),
        None,
        None,
    )?;

    let planner_clone = app_state.agents.planner_agent.clone();
    let app_state_clone = app_state.clone(); // Clone Arc<AppState>
    let app_handle_clone = app_handle.clone();

    // Run planning in a separate task
    tauri::async_runtime::spawn(async move {
        let mut session_for_planner = app_state_clone.current_project_session.lock();
        match planner_clone
            .lock()
            .analyze_and_decompose_spec(&spec_file_model, &mut session_for_planner, &settings_clone)
            .await
        {
            Ok(planner_logs) => {
                for log_entry in planner_logs {
                    let _ = log_to_state_and_emit(
                        &app_handle_clone,
                        &app_state_clone,
                        log_entry.component.clone(),
                        log_entry.level.clone(),
                        log_entry.message.clone(),
                        log_entry.task_id.clone(),
                        log_entry.details.clone(),
                    );
                }
                // Planner updates session status to ReadyToExecute internally
                // Now trigger the main execution loop if planning was successful
                if session_for_planner.status == ProjectStatus::ReadyToExecute {
                    drop(session_for_planner); // Release lock before calling another command that might lock
                    if let Err(e) = run_main_execution_loop(app_handle_clone, app_state_clone).await
                    {
                        let _ = log_to_state_and_emit(
                            &app_handle_clone,
                            &app_state_clone,
                            "System".into(),
                            LogLevel::Error,
                            format!("Execution loop failed: {:?}", e),
                            None,
                            None,
                        );
                        app_state_clone.current_project_session.lock().status =
                            ProjectStatus::Error(format!("Loop Error: {:?}", e));
                    }
                }
            }
            Err(e) => {
                let _ = log_to_state_and_emit(
                    &app_handle_clone,
                    &app_state_clone,
                    "PlannerAgent".into(),
                    LogLevel::Error,
                    format!("Decomposition failed: {:?}", e),
                    None,
                    None,
                );
                session_for_planner.status =
                    ProjectStatus::Error(format!("Planner Error: {:?}", e));
            }
        }
    });
    Ok(())
}

// This is the core execution loop, can be triggered after planning or by a command
async fn run_main_execution_loop(
    app_handle: AppHandle,
    app_state: State<'_, AppState>,
) -> AppResult<()> {
    log_to_state_and_emit(
        &app_handle,
        &app_state,
        "System".into(),
        LogLevel::Info,
        "Starting main execution loop...".into(),
        None,
        None,
    )?;
    loop {
        let mut task_to_run_opt: Option<Task> = None;
        let project_path_clone: String;
        let current_settings: ProjectSettings;
        let mut should_break_loop = false;

        {
            // --- Task Selection Scope ---
            let mut session = app_state.current_project_session.lock();
            project_path_clone = session
                .project_path
                .as_ref()
                .ok_or(AppError::Config("Project path not set in loop".to_string()))?
                .clone();
            current_settings = app_state.settings.lock().clone();

            match session.status {
                ProjectStatus::ReadyToExecute | ProjectStatus::SelfCorrecting(_) | ProjectStatus::CompletedGoal /* to pick up new specs if any */ | ProjectStatus::Idle /* if just started */ => {
                    // If SelfCorrecting, try to re-select the specific task being corrected.
                    let task_id_for_correction = if let ProjectStatus::SelfCorrecting(ref tid) = session.status { Some(tid.clone()) } else { None };

                    if let Some(tid) = task_id_for_correction {
                        task_to_run_opt = session.tasks.iter().find(|t| t.id == tid && t.current_attempt_number < current_settings.max_self_correction_attempts).cloned();
                        if task_to_run_opt.is_none() { // Max attempts reached or task not found
                            log_to_state_and_emit(&app_handle, &app_state, "PlannerAgent".into(), LogLevel::Error, format!("Failed to re-select task {} for self-correction or max attempts reached.", tid), Some(tid.clone()), None)?;
                            session.status = ProjectStatus::AwaitingHumanInput(format!("Task {} failed self-correction.", tid));
                            should_break_loop = true;
                        }
                    } else {
                        task_to_run_opt = app_state.agents.planner_agent.lock().select_next_task(&session).await.cloned();
                    }

                    if let Some(ref task) = task_to_run_opt {
                        session.status = ProjectStatus::ExecutingTask;
                        session.current_task_id_executing = Some(task.id.clone());
                        log_to_state_and_emit(&app_handle, &app_state, "PlannerAgent".into(), LogLevel::Info, format!("Selected task: {} ({})", task.description, task.id), Some(task.id.clone()), None)?;
                    } else {
                        log_to_state_and_emit(&app_handle, &app_state, "PlannerAgent".into(), LogLevel::Info, "No more runnable tasks found.".into(), None, None)?;
                        session.status = if session.tasks.iter().all(|t| t.status == TaskStatus::CompletedSuccess) { ProjectStatus::CompletedGoal } else { ProjectStatus::Idle }; // Or AwaitingHumanInput if some failed
                        should_break_loop = true;
                    }
                }
                ProjectStatus::ExecutingTask | ProjectStatus::Planning => {
                    // Already processing, loop will continue or another trigger will occur.
                    // This check prevents re-entry if loop is called while busy.
                    // This part of the logic might need refinement based on how `run_main_execution_loop` is invoked.
                    // For now, assume it's called once after planning, and then tasks are processed sequentially.
                    // If it's meant to be a persistent poller, this needs adjustment.
                    // For simplicity, let's assume it processes one task then exits, and is re-triggered.
                    // Or, if it's a true loop, it should await some signal or delay.
                    // For this iteration, let's make it process one task and then the loop condition will break if no more tasks.
                    should_break_loop = true; // Let current execution finish
                }
                _ => { // Paused, Error, AwaitingHumanInput, Unloaded
                    log_to_state_and_emit(&app_handle, &app_state, "System".into(), LogLevel::Warn, format!("Execution loop paused or in non-runnable state: {:?}", session.status), None, None)?;
                    should_break_loop = true;
                }
            }
        } // --- End Task Selection Scope (session lock released) ---

        if should_break_loop {
            break;
        }

        if let Some(mut task_to_run) = task_to_run_opt {
            let planner = app_state.agents.planner_agent.clone(); // Arc clone
            let coder = app_state.agents.coder_agent.clone();
            let workspace = app_state.services.workspace_service.clone();
            let knowledge_manager = app_state.services.knowledge_manager_service.clone();

            // 1. Prepare Context
            let (code_ctx, crate_docs_ctx, prep_logs) = planner
                .lock()
                .prepare_context_for_coder(&task_to_run, &project_path_clone, &current_settings)
                .await?;
            for log_entry in prep_logs {
                log_to_state_and_emit(
                    &app_handle,
                    &app_state,
                    log_entry.component,
                    log_entry.level,
                    log_entry.message,
                    log_entry.task_id,
                    log_entry.details,
                )?;
            }

            // Update task in session with context summary (if needed)
            app_state
                .current_project_session
                .lock()
                .tasks
                .iter_mut()
                .find(|t| t.id == task_to_run.id)
                .map(|t| {
                    t.context_summary = format!(
                        "Code Ctx: {} chars, Crate Docs: {} chars",
                        code_ctx.len(),
                        crate_docs_ctx.len()
                    )
                });

            // 2. Execute Task with Coder
            let (coder_output, coder_logs) = coder
                .lock()
                .execute_task(
                    &mut task_to_run,
                    &code_ctx,
                    &crate_docs_ctx,
                    &current_settings,
                )
                .await?;
            for log_entry in coder_logs {
                log_to_state_and_emit(
                    &app_handle,
                    &app_state,
                    log_entry.component,
                    log_entry.level,
                    log_entry.message,
                    log_entry.task_id,
                    log_entry.details,
                )?;
            }

            let mut final_task_status_for_this_attempt: TaskStatus;
            let mut verification_logs_combined = Vec::new();

            if coder_output.success {
                // 3. Apply Changes
                let apply_logs = workspace
                    .lock()
                    .apply_coder_output(&project_path_clone, &coder_output)
                    .await?;
                for log_entry in apply_logs {
                    log_to_state_and_emit(
                        &app_handle,
                        &app_state,
                        log_entry.component,
                        log_entry.level,
                        log_entry.message,
                        log_entry.task_id,
                        log_entry.details,
                    )?;
                }

                // 4. Verification Stages
                let verification_stages = ["fmt", "check", "clippy", "test"]; // TODO: Make configurable per task type
                let mut overall_verification_success = true;
                let mut combined_stdout = String::new();
                let mut combined_stderr = String::new();
                let mut last_exit_code = 0;

                for stage in verification_stages {
                    let emit_fn = Arc::new(|s: String| {
                        app_handle
                            .emit_filter("cargo-stream", |_t| true, s.clone())
                            .unwrap_or_default();
                    });
                    let (stdout, stderr, exit_code, stage_logs) = workspace
                        .lock()
                        .run_verification_stage(stage, &project_path_clone, emit_fn.clone())
                        .await?;
                    for log_entry in stage_logs {
                        verification_logs_combined.push(log_entry);
                    }
                    combined_stdout.push_str(&format!(
                        "\n--- {} STDOUT ---\n{}",
                        stage.to_uppercase(),
                        stdout
                    ));
                    combined_stderr.push_str(&format!(
                        "\n--- {} STDERR ---\n{}",
                        stage.to_uppercase(),
                        stderr
                    ));
                    last_exit_code = exit_code;
                    if exit_code != 0 {
                        overall_verification_success = false;
                        log_to_state_and_emit(
                            &app_handle,
                            &app_state,
                            "WorkspaceService".into(),
                            LogLevel::Warn,
                            format!(
                                "Verification stage '{}' FAILED for task {}",
                                stage, task_to_run.id
                            ),
                            Some(task_to_run.id.clone()),
                            Some(
                                serde_json::json!({"stage": stage, "exit_code": exit_code, "stderr": stderr }),
                            ),
                        )?;
                        break; // Stop further verification if one stage fails
                    } else {
                        log_to_state_and_emit(
                            &app_handle,
                            &app_state,
                            "WorkspaceService".into(),
                            LogLevel::Info,
                            format!(
                                "Verification stage '{}' PASSED for task {}",
                                stage, task_to_run.id
                            ),
                            Some(task_to_run.id.clone()),
                            None,
                        )?;
                    }
                }

                // 5. Process Coder Output & Verification (Planner decides final task status)
                let (status_after_verify, process_logs) = planner
                    .lock()
                    .process_coder_output_and_verification(
                        &mut task_to_run,
                        coder_output,
                        combined_stdout,
                        combined_stderr,
                        last_exit_code,
                        &mut app_state.current_project_session.lock(), // Pass mutable session
                        &current_settings,
                    )
                    .await?;
                final_task_status_for_this_attempt = status_after_verify;
                for log_entry in process_logs {
                    verification_logs_combined.push(log_entry);
                } // Add planner's processing logs
            } else {
                // Coder itself reported failure
                final_task_status_for_this_attempt = TaskStatus::BlockedByError(
                    coder_output
                        .error_message
                        .unwrap_or_else(|| "Coder indicated failure without details.".into()),
                );
                // Update task attempt record (as verification was skipped)
                if let Some(last_attempt) = task_to_run.attempts.last_mut() {
                    last_attempt.verification_exit_code = -1; // Indicate verification skipped
                    last_attempt.llm_error_summary =
                        Some(format!("{:?}", final_task_status_for_this_attempt));
                }
            }
            for log_entry in verification_logs_combined {
                log_to_state_and_emit(
                    &app_handle,
                    &app_state,
                    log_entry.component,
                    log_entry.level,
                    log_entry.message,
                    log_entry.task_id,
                    log_entry.details,
                )?;
            }

            // 6. Update Task and Session State (Final for this iteration)
            {
                // Scope for session lock
                let mut session = app_state.current_project_session.lock();
                if let Some(task_in_session) =
                    session.tasks.iter_mut().find(|t| t.id == task_to_run.id)
                {
                    task_in_session.status = final_task_status_for_this_attempt.clone();
                    task_in_session.attempts = task_to_run.attempts; // Persist attempts
                    task_in_session.last_coder_output = task_to_run.last_coder_output;
                    // Persist last output
                }

                // If task completed successfully, and git strategy is PerTask, commit.
                if final_task_status_for_this_attempt == TaskStatus::CompletedSuccess
                    && current_settings.git_commit_strategy == GitCommitStrategy::PerTask
                {
                    let commit_msg = format!(
                        "AI: Task {} - {} completed.",
                        task_to_run.id,
                        task_to_run.description.chars().take(50).collect::<String>()
                    );
                    let commit_logs = workspace
                        .lock()
                        .git_commit_changes(&project_path_clone, &commit_msg, Some(&task_to_run.id))
                        .await?;
                    for log_entry in commit_logs {
                        log_to_state_and_emit(
                            &app_handle,
                            &app_state,
                            log_entry.component,
                            log_entry.level,
                            log_entry.message,
                            log_entry.task_id,
                            log_entry.details,
                        )?;
                    }
                }

                // If task completed successfully, trigger file index update
                if final_task_status_for_this_attempt == TaskStatus::CompletedSuccess {
                    let km_clone = knowledge_manager.clone(); // Arc clone
                    let pp_clone = project_path_clone.clone();
                    let s_clone = current_settings.clone();
                    tauri::async_runtime::spawn(async move {
                        let _ = km_clone
                            .lock()
                            .update_project_file_index(&pp_clone, &s_clone)
                            .await;
                    });
                }

                // Set session status for next iteration or human input
                if session.status != ProjectStatus::SelfCorrecting(task_to_run.id.clone())
                    && session.status != ProjectStatus::AwaitingHumanInput("".into())
                {
                    // Avoid overriding these specific statuses
                    session.status = ProjectStatus::ReadyToExecute;
                }
                session.current_task_id_executing = None;
            } // session lock released
        } else {
            // This means select_next_task returned None, loop should have broken.
            log_to_state_and_emit(
                &app_handle,
                &app_state,
                "System".into(),
                LogLevel::Warn,
                "Execution loop entered iteration without a task to run. Breaking.".into(),
                None,
                None,
            )?;
            break;
        }
        // TODO: Add a small delay here if this is a tight loop, or make it event-driven.
        // For now, it will loop immediately to pick the next task.
    } // End loop
    log_to_state_and_emit(
        &app_handle,
        &app_state,
        "System".into(),
        LogLevel::Info,
        "Main execution loop finished.".into(),
        None,
        None,
    )?;
    Ok(())
}

#[tauri::command]
async fn submit_human_response(
    task_id: String,
    response_text: String,
    app_handle: AppHandle,
    app_state: State<'_, AppState>,
) -> AppResult<()> {
    // TODO:
    // 1. Find the task by task_id.
    // 2. Update its status (e.g., from AwaitingHumanInput to Pending/Ready).
    // 3. Store response_text in task.human_review_notes.
    // 4. Potentially modify task description or create new sub-tasks based on response.
    // 5. If system was AwaitingHumanInput, change status to ReadyToExecute to resume loop.
    log_to_state_and_emit(
        &app_handle,
        &app_state,
        "HumanInterface".into(),
        LogLevel::HumanInput,
        format!("Human response for task {}: {}", task_id, response_text),
        Some(task_id.clone()),
        None,
    )?;
    {
        let mut session = app_state.current_project_session.lock();
        if let Some(task) = session.tasks.iter_mut().find(|t| t.id == task_id) {
            task.human_review_notes = Some(response_text);
            if matches!(
                task.status,
                TaskStatus::AwaitingHumanClarification | TaskStatus::Failed
            ) {
                // Assuming Failed tasks might also get human input
                task.status = TaskStatus::Pending; // Reset for re-evaluation by planner
            }
        }
        if matches!(session.status, ProjectStatus::AwaitingHumanInput(_)) {
            session.status = ProjectStatus::ReadyToExecute;
        }
    }
    // Optionally, re-trigger the execution loop if it was paused waiting for this.
    // run_main_execution_loop(app_handle, app_state).await?;
    Ok(())
}

#[tauri::command]
async fn get_crate_info_cmd(
    crate_name: String,
    app_state: State<'_, AppState>,
) -> AppResult<Option<CrateInfo>> {
    let project_root = app_state
        .current_project_session
        .lock()
        .project_path
        .as_ref()
        .ok_or(AppError::Config("Project not loaded".into()))?
        .clone();
    let (info_opt, _logs) = app_state
        .services
        .knowledge_manager_service
        .lock()
        .get_crate_documentation_summary(&project_root, &crate_name)
        .await?;
    // This command needs to be reworked to return CrateInfo, not just summary.
    // For now, placeholder:
    if info_opt.is_some() {
        Ok(Some(CrateInfo {
            name: crate_name,
            version: None,
            approval_status: CrateApprovalStatus::Pending,
            documentation_summary: info_opt,
            source_url: None,
            last_qualified_at: None,
        }))
    } else {
        Ok(None)
    }
}

#[tauri::command]
async fn approve_crate_cmd(
    crate_name: String,
    app_state: State<'_, AppState>,
    app_handle: AppHandle,
) -> AppResult<()> {
    // TODO: Update the status of the crate in `CurrentProjectSession.known_crates`.
    // Persist this approval (e.g., to a manifest file in `docs/crate-docs/`).
    log_to_state_and_emit(
        &app_handle,
        &app_state,
        "KnowledgeManager".into(),
        LogLevel::Info,
        format!("Crate {} approved by user.", crate_name),
        None,
        None,
    )?;
    Ok(())
}

#[tauri::command]
async fn rebuild_project_search_index(
    app_handle: AppHandle,
    app_state: State<'_, AppState>,
) -> AppResult<()> {
    let session = app_state.current_project_session.lock();
    let project_root = session
        .project_path
        .as_ref()
        .ok_or(AppError::Config("Project not loaded".into()))?
        .clone();
    let settings = app_state.settings.lock().clone();
    drop(session); // Release lock

    log_to_state_and_emit(
        &app_handle,
        &app_state,
        "KnowledgeManager".into(),
        LogLevel::Info,
        "Manual search index rebuild initiated.".into(),
        None,
        None,
    )?;

    let km_clone = app_state.services.knowledge_manager_service.clone();
    // Run in background as it can be long
    tauri::async_runtime::spawn(async move {
        match km_clone
            .lock()
            .rebuild_full_index(&project_root, &settings)
            .await
        {
            Ok(logs) => {
                for log_entry in logs {
                    let _ = log_to_state_and_emit(
                        &app_handle,
                        &app_state,
                        log_entry.component,
                        log_entry.level,
                        log_entry.message,
                        log_entry.task_id,
                        log_entry.details,
                    );
                }
            }
            Err(e) => {
                let _ = log_to_state_and_emit(
                    &app_handle,
                    &app_state,
                    "KnowledgeManager".into(),
                    LogLevel::Error,
                    format!("Index rebuild failed: {:?}", e),
                    None,
                    None,
                );
            }
        }
    });
    Ok(())
}

#[tauri::command]
async fn search_project_globally(
    query: String,
    doc_type_filter: Option<String>,
    limit: Option<usize>,
    app_handle: AppHandle,
    app_state: State<'_, AppState>,
) -> AppResult<Vec<TantivySearchResultItem>> {
    let session = app_state.current_project_session.lock();
    let project_root = session
        .project_path
        .as_ref()
        .ok_or(AppError::Config("Project not loaded".into()))?
        .clone();
    drop(session);

    log_to_state_and_emit(
        &app_handle,
        &app_state,
        "KnowledgeManager".into(),
        LogLevel::Info,
        format!("Global search initiated for query: {}", query),
        None,
        None,
    )?;

    let km = app_state.services.knowledge_manager_service.lock();
    let (results, search_logs) = km
        .search_index(
            &query,
            limit.unwrap_or(10),
            doc_type_filter.as_deref(),
            &project_root,
        )
        .await?;
    for log_entry in search_logs {
        log_to_state_and_emit(
            &app_handle,
            &app_state,
            log_entry.component,
            log_entry.level,
            log_entry.message,
            log_entry.task_id,
            log_entry.details,
        )?;
    }
    Ok(results)
}

// In main function, add new commands to handler:
// .invoke_handler(tauri::generate_handler![
//     // ... existing commands ...
//     rebuild_project_search_index,
//     search_project_globally
// ])

#[tauri::command]
async fn search_project_globally(
    query: String,
    doc_type_filter: Option<String>,
    limit: Option<usize>,
    app_handle: AppHandle,
    app_state: State<'_, AppState>,
) -> AppResult<Vec<TantivySearchResultItem>> {
    // ... (Full implementation from previous response) ...
    Ok(vec![])
}

// --- Main Application Entry Point ---
fn main() {
    let app_state_instance = AppState::new();

    tauri::Builder::default()
        .manage(app_state_instance)
        .invoke_handler(tauri::generate_handler![
            load_settings,
            save_settings,
            initialize_project,
            scaffold_project_cmd,
            get_current_session_state,
            load_spec_files_from_project,
            start_full_processing_for_spec,
            submit_human_response,
            get_crate_info_cmd,
            approve_crate_cmd,
            rebuild_project_search_index,
            search_project_globally
        ])
        .setup(|app| {
            let handle = app.handle().clone();
            let app_state_clone = app.state::<AppState>().clone();
            let _ = log_to_state_and_emit(
                &handle,
                &app_state_clone,
                "System".into(),
                LogLevel::Info,
                "Cognito Pilot application started.".into(),
                None,
                None,
            );
            #[cfg(debug_assertions)]
            {
                if let Some(main_window) = app.get_webview_window("main") {
                    main_window.open_devtools();
                }
            }
            Ok(())
        })
        .build(tauri::generate_context!())
        .expect("error while building tauri application")
        .run(|_app_handle, event| match event {
            RunEvent::ExitRequested { api, .. } => {
                tracing::info!("App exit requested.");
                // TODO: Add cleanup logic here
                // api.prevent_exit(); // Uncomment to prevent closing
            }
            _ => {}
        });
}
</file>

<file path="src/App.tsx">
import { useState, useEffect, useCallback } from "react";
import { tauriApi, listenToGlobalLogEvents, listenToCargoStreamEvents, listenToHumanInputRequestEvents, GlobalLogEntry, CurrentProjectSession } from "./utils/tauriApi";
import Nav, { ViewName } from "./components/Nav";
import Dashboard from "./components/Dashboard";
import SpecsView from "./components/SpecsView";
import TaskProgressView from "./components/TaskProgressView";
import KnowledgeBaseView from "./components/KnowledgeBaseView";
import SystemTerminalView from "./components/SystemTerminalView";
import SettingsView from "./components/SettingsView";
import HumanInputDialog from "./components/HumanInputDialog";

function App() {
  const [currentView, setCurrentView] = useState<ViewName>("Dashboard");
  const [sessionState, setSessionState] = useState<CurrentProjectSession | null>(null);
  const [logs, setLogs] = useState<GlobalLogEntry[]>([]);
  const [cargoStream, setCargoStream] = useState<string[]>([]);
  const [humanInputRequest, setHumanInputRequest] = useState<{taskId: string, prompt: string} | null>(null);

  const refreshSessionState = useCallback(() => {
    tauriApi.getCurrentSessionState()
      .then(state => setSessionState(state))
      .catch(err => console.error("Failed to get session state:", err));
  }, []);

  useEffect(() => {
    refreshSessionState();
    const unlistenLogs = listenToGlobalLogEvents((event) => {
      setLogs(prev => [...prev, event.payload].sort((a, b) => a.timestamp - b.timestamp).slice(-200));
      if (event.payload.level === "Error" || event.payload.message.includes("loop finished") || event.payload.message.includes("Decomposition complete")) {
          refreshSessionState();
      }
    });
    const unlistenCargo = listenToCargoStreamEvents((event) => setCargoStream(prev => [...prev, event.payload].slice(-100)));
    const unlistenHumanInput = listenToHumanInputRequestEvents((event) => setHumanInputRequest(event.payload));
    const intervalId = setInterval(refreshSessionState, 5000);
    return () => {
      unlistenLogs.then(f => f());
      unlistenCargo.then(f => f());
      unlistenHumanInput.then(f => f());
      clearInterval(intervalId);
    };
  }, [refreshSessionState]);

  const handleHumanResponseSubmit = async (taskId: string, responseText: string) => {
    try {
        await tauriApi.submitHumanResponse(taskId, responseText);
        setHumanInputRequest(null);
        refreshSessionState();
    } catch (error) { console.error("Failed to submit human response:", error); }
  };

  const renderView = () => {
    switch (currentView) {
      case "Dashboard": return <Dashboard sessionState={sessionState} />;
      case "Specs": return <SpecsView refreshSessionState={refreshSessionState} />;
      case "Tasks": return <TaskProgressView tasks={sessionState?.tasks || []} currentExecutingTaskId={sessionState?.current_task_id_executing} />;
      case "Knowledge": return <KnowledgeBaseView knownCrates={sessionState?.known_crates || []} />;
      case "Terminal": return <SystemTerminalView logs={logs} cargoStream={cargoStream} />;
      case "Settings": return <SettingsView />;
      default: return <Dashboard sessionState={sessionState} />;
    }
  };

  return (
    <div className="flex h-screen bg-gray-900 text-gray-100 font-sans">
      <Nav setCurrentView={setCurrentView} currentView={currentView} />
      <main className="flex-1 p-6 ml-56 overflow-y-auto">
        {renderView()}
      </main>
      {humanInputRequest && (
        <HumanInputDialog
          taskId={humanInputRequest.taskId}
          prompt={humanInputRequest.prompt}
          onSubmit={handleHumanResponseSubmit}
          onClose={() => setHumanInputRequest(null)}
        />
      )}
    </div>
  );
}
export default App;
</file>

</files>
